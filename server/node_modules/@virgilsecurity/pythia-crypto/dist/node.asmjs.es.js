import initPythiaModules from '@virgilsecurity/core-pythia/node.asmjs.es.js';
import { dataToUint8Array, toBuffer } from '@virgilsecurity/data-utils';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

let pythiaModules;
const setPythiaModules = (modules) => {
    if (pythiaModules) {
        // eslint-disable-next-line no-console
        console.warn('Pythia modules are already set. Further calls to `setPythiaModules` are ignored.');
        return;
    }
    pythiaModules = modules;
    const { Pythia } = pythiaModules;
    try {
        Pythia.configure();
    }
    catch (error) {
        Pythia.cleanup();
        throw error;
    }
};
const getPythiaModules = () => {
    if (!pythiaModules) {
        throw new Error('You need to call `setPythiaModules` first');
    }
    return pythiaModules;
};
const hasPythiaModules = () => typeof pythiaModules !== 'undefined';

function initPythia() {
    return __awaiter(this, void 0, void 0, function* () {
        if (hasPythiaModules()) {
            // eslint-disable-next-line no-console
            console.warn('Pythia modules are already set. Further calls to `initPythia` are ignored.');
            return;
        }
        const pythiaModules = yield initPythiaModules();
        setPythiaModules(pythiaModules);
    });
}

class VirgilBrainKeyCrypto {
    blind(password) {
        const { Pythia } = getPythiaModules();
        const myPassword = dataToUint8Array(password, 'utf8');
        const { blindedPassword, blindingSecret } = Pythia.blind(myPassword);
        return {
            blindedPassword: toBuffer(blindedPassword),
            blindingSecret: toBuffer(blindingSecret),
        };
    }
    deblind(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindingSecret = dataToUint8Array(options.blindingSecret, 'base64');
        const result = Pythia.deblind(myTransformedPassword, myBlindingSecret);
        return toBuffer(result);
    }
}

class VirgilPythiaCrypto {
    constructor(virgilBrainKeyCrypto) {
        this.virgilBrainKeyCrypto = virgilBrainKeyCrypto || new VirgilBrainKeyCrypto();
    }
    blind(password) {
        return this.virgilBrainKeyCrypto.blind(password);
    }
    deblind(options) {
        return this.virgilBrainKeyCrypto.deblind(options);
    }
    computeTransformationKeyPair(options) {
        const { Pythia } = getPythiaModules();
        const myTransformationKeyId = dataToUint8Array(options.transformationKeyId, 'base64');
        const myPythiaSecret = dataToUint8Array(options.pythiaSecret, 'base64');
        const myPythiaScopeSecret = dataToUint8Array(options.pythiaScopeSecret, 'base64');
        const { transformationPrivateKey, transformationPublicKey, } = Pythia.computeTransformationKeyPair(myTransformationKeyId, myPythiaSecret, myPythiaScopeSecret);
        return {
            privateKey: toBuffer(transformationPrivateKey),
            publicKey: toBuffer(transformationPublicKey),
        };
    }
    transform(options) {
        const { Pythia } = getPythiaModules();
        const myBlindedPassword = dataToUint8Array(options.blindedPassword, 'base64');
        const myTweak = dataToUint8Array(options.tweak, 'base64');
        const myTransformationPrivateKey = dataToUint8Array(options.transformationPrivateKey, 'base64');
        const { transformedPassword, transformedTweak } = Pythia.transform(myBlindedPassword, myTweak, myTransformationPrivateKey);
        return {
            transformedPassword: toBuffer(transformedPassword),
            transformedTweak: toBuffer(transformedTweak),
        };
    }
    prove(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindedPassword = dataToUint8Array(options.blindedPassword, 'base64');
        const myTransformedTweak = dataToUint8Array(options.transformedTweak, 'base64');
        const { proofValueC, proofValueU } = Pythia.prove(myTransformedPassword, myBlindedPassword, myTransformedTweak, options.transformationKeyPair.privateKey, options.transformationKeyPair.publicKey);
        return {
            proofValueC: toBuffer(proofValueC),
            proofValueU: toBuffer(proofValueU),
        };
    }
    verify(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindedPassword = dataToUint8Array(options.blindedPassword, 'base64');
        const myTweak = dataToUint8Array(options.tweak, 'base64');
        const myTransformationPublicKey = dataToUint8Array(options.transformationPublicKey, 'base64');
        const myProofValueC = dataToUint8Array(options.proofValueC, 'base64');
        const myProofValueU = dataToUint8Array(options.proofValueU, 'base64');
        return Pythia.verify(myTransformedPassword, myBlindedPassword, myTweak, myTransformationPublicKey, myProofValueC, myProofValueU);
    }
    getPasswordUpdateToken(options) {
        const { Pythia } = getPythiaModules();
        const myOldTransformationPrivateKey = dataToUint8Array(options.oldTransformationPrivateKey, 'base64');
        const myNewTransformationPrivateKey = dataToUint8Array(options.newTransformationPrivateKey, 'base64');
        const passwordUpdateToken = Pythia.getPasswordUpdateToken(myOldTransformationPrivateKey, myNewTransformationPrivateKey);
        return toBuffer(passwordUpdateToken);
    }
    updateDeblindedWithToken(options) {
        const { Pythia } = getPythiaModules();
        const myDeblindedPassword = dataToUint8Array(options.deblindedPassword, 'base64');
        const myUpdateToken = dataToUint8Array(options.updateToken, 'base64');
        const result = Pythia.updateDeblindedWithToken(myDeblindedPassword, myUpdateToken);
        return toBuffer(result);
    }
}

export { VirgilBrainKeyCrypto, VirgilPythiaCrypto, getPythiaModules, hasPythiaModules, initPythia, setPythiaModules };
