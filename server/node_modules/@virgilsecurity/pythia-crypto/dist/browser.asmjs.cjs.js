'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var initPythiaModules = _interopDefault(require('@virgilsecurity/core-pythia/browser.asmjs.cjs.js'));
var dataUtils = require('@virgilsecurity/data-utils');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

let pythiaModules;
const setPythiaModules = (modules) => {
    if (pythiaModules) {
        // eslint-disable-next-line no-console
        console.warn('Pythia modules are already set. Further calls to `setPythiaModules` are ignored.');
        return;
    }
    pythiaModules = modules;
    const { Pythia } = pythiaModules;
    try {
        Pythia.configure();
    }
    catch (error) {
        Pythia.cleanup();
        throw error;
    }
};
const getPythiaModules = () => {
    if (!pythiaModules) {
        throw new Error('You need to call `setPythiaModules` first');
    }
    return pythiaModules;
};
const hasPythiaModules = () => typeof pythiaModules !== 'undefined';

function initPythia() {
    return __awaiter(this, void 0, void 0, function* () {
        if (hasPythiaModules()) {
            // eslint-disable-next-line no-console
            console.warn('Pythia modules are already set. Further calls to `initPythia` are ignored.');
            return;
        }
        const pythiaModules = yield initPythiaModules();
        setPythiaModules(pythiaModules);
    });
}

class VirgilBrainKeyCrypto {
    blind(password) {
        const { Pythia } = getPythiaModules();
        const myPassword = dataUtils.dataToUint8Array(password, 'utf8');
        const { blindedPassword, blindingSecret } = Pythia.blind(myPassword);
        return {
            blindedPassword: dataUtils.toBuffer(blindedPassword),
            blindingSecret: dataUtils.toBuffer(blindingSecret),
        };
    }
    deblind(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataUtils.dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindingSecret = dataUtils.dataToUint8Array(options.blindingSecret, 'base64');
        const result = Pythia.deblind(myTransformedPassword, myBlindingSecret);
        return dataUtils.toBuffer(result);
    }
}

class VirgilPythiaCrypto {
    constructor(virgilBrainKeyCrypto) {
        this.virgilBrainKeyCrypto = virgilBrainKeyCrypto || new VirgilBrainKeyCrypto();
    }
    blind(password) {
        return this.virgilBrainKeyCrypto.blind(password);
    }
    deblind(options) {
        return this.virgilBrainKeyCrypto.deblind(options);
    }
    computeTransformationKeyPair(options) {
        const { Pythia } = getPythiaModules();
        const myTransformationKeyId = dataUtils.dataToUint8Array(options.transformationKeyId, 'base64');
        const myPythiaSecret = dataUtils.dataToUint8Array(options.pythiaSecret, 'base64');
        const myPythiaScopeSecret = dataUtils.dataToUint8Array(options.pythiaScopeSecret, 'base64');
        const { transformationPrivateKey, transformationPublicKey, } = Pythia.computeTransformationKeyPair(myTransformationKeyId, myPythiaSecret, myPythiaScopeSecret);
        return {
            privateKey: dataUtils.toBuffer(transformationPrivateKey),
            publicKey: dataUtils.toBuffer(transformationPublicKey),
        };
    }
    transform(options) {
        const { Pythia } = getPythiaModules();
        const myBlindedPassword = dataUtils.dataToUint8Array(options.blindedPassword, 'base64');
        const myTweak = dataUtils.dataToUint8Array(options.tweak, 'base64');
        const myTransformationPrivateKey = dataUtils.dataToUint8Array(options.transformationPrivateKey, 'base64');
        const { transformedPassword, transformedTweak } = Pythia.transform(myBlindedPassword, myTweak, myTransformationPrivateKey);
        return {
            transformedPassword: dataUtils.toBuffer(transformedPassword),
            transformedTweak: dataUtils.toBuffer(transformedTweak),
        };
    }
    prove(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataUtils.dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindedPassword = dataUtils.dataToUint8Array(options.blindedPassword, 'base64');
        const myTransformedTweak = dataUtils.dataToUint8Array(options.transformedTweak, 'base64');
        const { proofValueC, proofValueU } = Pythia.prove(myTransformedPassword, myBlindedPassword, myTransformedTweak, options.transformationKeyPair.privateKey, options.transformationKeyPair.publicKey);
        return {
            proofValueC: dataUtils.toBuffer(proofValueC),
            proofValueU: dataUtils.toBuffer(proofValueU),
        };
    }
    verify(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataUtils.dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindedPassword = dataUtils.dataToUint8Array(options.blindedPassword, 'base64');
        const myTweak = dataUtils.dataToUint8Array(options.tweak, 'base64');
        const myTransformationPublicKey = dataUtils.dataToUint8Array(options.transformationPublicKey, 'base64');
        const myProofValueC = dataUtils.dataToUint8Array(options.proofValueC, 'base64');
        const myProofValueU = dataUtils.dataToUint8Array(options.proofValueU, 'base64');
        return Pythia.verify(myTransformedPassword, myBlindedPassword, myTweak, myTransformationPublicKey, myProofValueC, myProofValueU);
    }
    getPasswordUpdateToken(options) {
        const { Pythia } = getPythiaModules();
        const myOldTransformationPrivateKey = dataUtils.dataToUint8Array(options.oldTransformationPrivateKey, 'base64');
        const myNewTransformationPrivateKey = dataUtils.dataToUint8Array(options.newTransformationPrivateKey, 'base64');
        const passwordUpdateToken = Pythia.getPasswordUpdateToken(myOldTransformationPrivateKey, myNewTransformationPrivateKey);
        return dataUtils.toBuffer(passwordUpdateToken);
    }
    updateDeblindedWithToken(options) {
        const { Pythia } = getPythiaModules();
        const myDeblindedPassword = dataUtils.dataToUint8Array(options.deblindedPassword, 'base64');
        const myUpdateToken = dataUtils.dataToUint8Array(options.updateToken, 'base64');
        const result = Pythia.updateDeblindedWithToken(myDeblindedPassword, myUpdateToken);
        return dataUtils.toBuffer(result);
    }
}

exports.VirgilBrainKeyCrypto = VirgilBrainKeyCrypto;
exports.VirgilPythiaCrypto = VirgilPythiaCrypto;
exports.getPythiaModules = getPythiaModules;
exports.hasPythiaModules = hasPythiaModules;
exports.initPythia = initPythia;
exports.setPythiaModules = setPythiaModules;
