import { NodeBuffer, dataToUint8Array, toBuffer } from '@virgilsecurity/data-utils';

/// <reference types="@virgilsecurity/core-foundation" />
let foundationModules;
const setFoundationModules = (modules) => {
    if (foundationModules) {
        // eslint-disable-next-line no-console
        console.warn('Foundation modules are already set. Further calls to `setFoundationModules` are ignored.');
        return;
    }
    foundationModules = modules;
};
const getFoundationModules = () => {
    if (!foundationModules) {
        throw new Error('You need to call `setFoundationModules` first');
    }
    return foundationModules;
};
const hasFoundationModules = () => typeof foundationModules !== 'undefined';

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const addHashAlgorithm = (obj, algIdName) => {
    Object.defineProperty(obj, algIdName, {
        configurable: false,
        enumerable: true,
        get: () => {
            const { AlgId } = getFoundationModules();
            return AlgId[algIdName];
        },
    });
};
// eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
const HashAlgorithm = {};
addHashAlgorithm(HashAlgorithm, 'SHA224');
addHashAlgorithm(HashAlgorithm, 'SHA256');
addHashAlgorithm(HashAlgorithm, 'SHA384');
addHashAlgorithm(HashAlgorithm, 'SHA512');

const addKeyPairType = (obj, name, algIdName, bitlen) => {
    Object.defineProperty(obj, name, {
        configurable: false,
        enumerable: true,
        get: () => {
            const { AlgId } = getFoundationModules();
            return {
                bitlen,
                algId: AlgId[algIdName],
            };
        },
    });
};
// eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
const KeyPairType = {};
addKeyPairType(KeyPairType, 'Default', 'ED25519');
addKeyPairType(KeyPairType, 'ED25519', 'ED25519');
addKeyPairType(KeyPairType, 'CURVE25519', 'CURVE25519');
addKeyPairType(KeyPairType, 'SECP256R1', 'SECP256R1');
addKeyPairType(KeyPairType, 'RSA_2048', 'RSA', 2048);
addKeyPairType(KeyPairType, 'RSA_3072', 'RSA', 3072);
addKeyPairType(KeyPairType, 'RSA_4096', 'RSA', 4096);
addKeyPairType(KeyPairType, 'RSA_8192', 'RSA', 8192);

const DATA_SIGNATURE_KEY = NodeBuffer.from('VIRGIL-DATA-SIGNATURE', 'utf8');
const DATA_SIGNER_ID_KEY = NodeBuffer.from('VIRGIL-DATA-SIGNER-ID', 'utf8');

let keyProvider;
const getKeyProvider = () => {
    if (keyProvider) {
        return keyProvider;
    }
    const foundationModules = getFoundationModules();
    keyProvider = new foundationModules.KeyProvider();
    try {
        keyProvider.setupDefaults();
    }
    catch (error) {
        keyProvider.delete();
        keyProvider = undefined;
        throw error;
    }
    return keyProvider;
};
const importPrivateKey = (serializedPrivateKey) => getKeyProvider().importPrivateKey(serializedPrivateKey);
const importPublicKey = (serializedPublicKey) => getKeyProvider().importPublicKey(serializedPublicKey);

let keySerializer;
const getKeySerializer = () => {
    if (keySerializer) {
        return keySerializer;
    }
    const foundationModules = getFoundationModules();
    keySerializer = new foundationModules.KeyAsn1Serializer();
    try {
        keySerializer.setupDefaults();
    }
    catch (error) {
        keySerializer.delete();
        keySerializer = undefined;
        throw error;
    }
    return keySerializer;
};
const serializePrivateKey = (lowLevelPrivateKey) => getKeySerializer().serializePrivateKey(lowLevelPrivateKey);
const serializePublicKey = (lowLevelPublicKey) => getKeySerializer().serializePublicKey(lowLevelPublicKey);

const privateKeys = new WeakMap();
const setValue = WeakMap.prototype.set;
const getValue = WeakMap.prototype.get;
const hasValue = WeakMap.prototype.has;
function getLowLevelPrivateKey(privateKey) {
    const serializedPrivateKey = getValue.call(privateKeys, privateKey);
    return importPrivateKey(serializedPrivateKey);
}
function setLowLevelPrivateKey(privateKey, serializedPrivateKey) {
    setValue.call(privateKeys, privateKey, serializedPrivateKey);
}
function hasLowLevelPrivateKey(privateKey) {
    return hasValue.call(privateKeys, privateKey);
}

const toArray = (val) => {
    return val == null ? [] : Array.isArray(val) ? val : [val];
};
const getLowLevelPublicKeys = (publicKeys) => {
    const lowLevelPublicKeys = [];
    publicKeys.forEach(({ key }) => {
        try {
            const lowLevelPublicKey = importPublicKey(key);
            lowLevelPublicKeys.push(lowLevelPublicKey);
        }
        catch (error) {
            lowLevelPublicKeys.forEach(lowLevelPublicKey => lowLevelPublicKey.delete());
            throw error;
        }
    });
    return lowLevelPublicKeys;
};

function validatePrivateKey(privateKey, label = 'privateKey') {
    if (privateKey == null ||
        !(privateKey.identifier instanceof Uint8Array) ||
        !hasLowLevelPrivateKey(privateKey)) {
        throw new TypeError(`\`${label}\` is not a VirgilPrivateKey.`);
    }
}
function validatePublicKey(publicKey, label = 'publicKey') {
    if (publicKey == null ||
        !(publicKey.identifier instanceof Uint8Array) ||
        !(publicKey.key instanceof Uint8Array)) {
        throw new TypeError(`\`${label}\` is not a VirgilPublicKey.`);
    }
}
function validatePublicKeysArray(publicKeys, label = 'publicKeys') {
    if (publicKeys.length === 0) {
        throw new TypeError(`\`${label}\` array must not be empty.`);
    }
    publicKeys.forEach(publicKey => validatePublicKey(publicKey));
}

class VirgilPrivateKey {
    constructor(indentifier, key) {
        this.identifier = indentifier;
        setLowLevelPrivateKey(this, key);
    }
}

class VirgilPublicKey {
    constructor(identifier, key) {
        this.identifier = identifier;
        this.key = key;
    }
}

class VirgilStreamCipher {
    constructor(publicKey, signature) {
        this.isFinished = false;
        this.isRunning = false;
        this.isDisposed = false;
        this.lowLevelPublicKeys = [];
        const foundationModules = getFoundationModules();
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        this.lowLevelPublicKeys = getLowLevelPublicKeys(publicKeys);
        this.ctrDrbg = new foundationModules.CtrDrbg();
        try {
            this.ctrDrbg.setupDefaults();
        }
        catch (error) {
            this.lowLevelPublicKeys.forEach(lowLevelPublicKey => lowLevelPublicKey.delete());
            this.ctrDrbg.delete();
            throw error;
        }
        this.recipientCipher = new foundationModules.RecipientCipher();
        this.aes256Gcm = new foundationModules.Aes256Gcm();
        this.recipientCipher.encryptionCipher = this.aes256Gcm;
        this.recipientCipher.random = this.ctrDrbg;
        publicKeys.forEach(({ identifier }, index) => {
            this.recipientCipher.addKeyRecipient(identifier, this.lowLevelPublicKeys[index]);
        });
        if (signature) {
            const mySignature = dataToUint8Array(signature, 'base64');
            this.messageInfoCustomParams = this.recipientCipher.customParams();
            this.messageInfoCustomParams.addData(DATA_SIGNATURE_KEY, mySignature);
        }
    }
    start() {
        this.ensureLegalState();
        this.recipientCipher.startEncryption();
        this.isRunning = true;
        return toBuffer(this.recipientCipher.packMessageInfo());
    }
    update(data) {
        this.ensureLegalState();
        this.ensureIsRunning();
        const myData = dataToUint8Array(data, 'utf8');
        return toBuffer(this.recipientCipher.processEncryption(myData));
    }
    final(dispose = true) {
        this.ensureLegalState();
        this.ensureIsRunning();
        try {
            return toBuffer(this.recipientCipher.finishEncryption());
        }
        finally {
            this.isFinished = true;
            this.isRunning = false;
            if (dispose) {
                this.dispose();
            }
        }
    }
    dispose() {
        this.lowLevelPublicKeys.forEach(lowLevelPublicKey => lowLevelPublicKey.delete());
        this.recipientCipher.delete();
        this.aes256Gcm.delete();
        this.ctrDrbg.delete();
        if (this.messageInfoCustomParams) {
            this.messageInfoCustomParams.delete();
        }
        this.isDisposed = true;
    }
    ensureLegalState() {
        if (this.isFinished) {
            throw new Error('Illegal state. Cannot use cipher after the `final` method has been called.');
        }
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot use cipher after the `dispose` method has been called.');
        }
    }
    ensureIsRunning() {
        if (!this.isRunning) {
            throw new Error('Illegal state. Cannot use cipher before the `start` method.');
        }
    }
}

class VirgilStreamDecipher {
    constructor(privateKey) {
        this.isFinished = false;
        this.isDisposed = false;
        const foundationModules = getFoundationModules();
        validatePrivateKey(privateKey);
        this.lowLevelPrivateKey = getLowLevelPrivateKey(privateKey);
        this.recipientCipher = new foundationModules.RecipientCipher();
        try {
            this.recipientCipher.startDecryptionWithKey(privateKey.identifier, this.lowLevelPrivateKey, new Uint8Array(0));
        }
        catch (error) {
            this.lowLevelPrivateKey.delete();
            this.recipientCipher.delete();
            throw error;
        }
    }
    getSignature() {
        if (!this.isFinished) {
            throw new Error('Illegal state. Cannot get signature before the `final` method has been called.');
        }
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot get signature after the `dispose` method has been called.');
        }
        const messageInfoCustomParams = this.recipientCipher.customParams();
        try {
            return toBuffer(messageInfoCustomParams.findData(DATA_SIGNATURE_KEY));
        }
        finally {
            messageInfoCustomParams.delete();
        }
    }
    update(data) {
        this.ensureLegalState();
        const myData = dataToUint8Array(data, 'utf8');
        return toBuffer(this.recipientCipher.processDecryption(myData));
    }
    final(dispose = true) {
        this.ensureLegalState();
        try {
            return toBuffer(this.recipientCipher.finishDecryption());
        }
        finally {
            this.isFinished = true;
            if (dispose) {
                this.dispose();
            }
        }
    }
    dispose() {
        this.lowLevelPrivateKey.delete();
        this.recipientCipher.delete();
        this.isDisposed = true;
    }
    ensureLegalState() {
        if (this.isFinished) {
            throw new Error('Illegal state. Cannot use cipher after the `final` method has been called.');
        }
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot use cipher after the `dispose` method has been called.');
        }
    }
}

class VirgilStreamSigner {
    constructor() {
        this.isDisposed = false;
        const foundationModules = getFoundationModules();
        this.signer = new foundationModules.Signer();
        this.sha512 = new foundationModules.Sha512();
        this.signer.hash = this.sha512;
        this.signer.reset();
    }
    update(data) {
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot use signer after the `dispose` method has been called.');
        }
        const myData = dataToUint8Array(data, 'utf8');
        this.signer.appendData(myData);
        return this;
    }
    sign(privateKey, final = true) {
        if (this.isDisposed) {
            throw new Error('Illegal state. The VirgilStreamSigner has been disposed. ' +
                'Pass `false` as the second argument to the `sign` method ' +
                'if you need to generate more than one signature.');
        }
        validatePrivateKey(privateKey);
        const lowLevelPrivateKey = getLowLevelPrivateKey(privateKey);
        try {
            const result = this.signer.sign(lowLevelPrivateKey);
            if (final) {
                this.dispose();
            }
            return toBuffer(result);
        }
        finally {
            lowLevelPrivateKey.delete();
        }
    }
    dispose() {
        this.signer.delete();
        this.sha512.delete();
    }
}

class VirgilStreamVerifier {
    constructor(signature) {
        this.isDisposed = false;
        const foundationModules = getFoundationModules();
        const mySignature = dataToUint8Array(signature, 'base64');
        this.verifier = new foundationModules.Verifier();
        try {
            this.verifier.reset(mySignature);
        }
        catch (error) {
            this.verifier.delete();
            throw error;
        }
    }
    update(data) {
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot use signer after the `dispose` method has been called.');
        }
        const myData = dataToUint8Array(data, 'utf8');
        this.verifier.appendData(myData);
        return this;
    }
    verify(publicKey, final = true) {
        if (this.isDisposed) {
            throw new Error('Illegal state. The VirgilStreamVerifier has been disposed. ' +
                'Pass `false` as the second argument to the `verify` method ' +
                'if you need to verify with more than one public key.');
        }
        validatePublicKey(publicKey);
        const lowLevelPublicKey = importPublicKey(publicKey.key);
        const result = this.verifier.verify(lowLevelPublicKey);
        lowLevelPublicKey.delete();
        if (final) {
            this.dispose();
        }
        return result;
    }
    dispose() {
        this.verifier.delete();
        this.isDisposed = true;
    }
}

const getRandom = (() => {
    let random;
    return () => {
        if (!random) {
            random = new (getFoundationModules()).CtrDrbg();
            try {
                random.setupDefaults();
            }
            catch (error) {
                random.delete();
                random = undefined;
                throw error;
            }
        }
        return random;
    };
})();
function parseGroupSessionMessage(messageData) {
    const message = getFoundationModules().GroupSessionMessage.deserialize(messageData);
    const info = {
        epochNumber: message.getEpoch(),
        sessionId: toBuffer(message.getSessionId()).toString('hex'),
        data: toBuffer(messageData).toString('base64'),
    };
    message.delete();
    return info;
}
function getEpochNumberFromEpochMessage(epochMessageData) {
    const epoch = getFoundationModules().GroupSessionMessage.deserialize(epochMessageData);
    const epochNumber = epoch.getEpoch();
    epoch.delete();
    return epochNumber;
}
function createLowLevelSession(epochMessages) {
    const session = new (getFoundationModules()).GroupSession();
    session.rng = getRandom();
    const deleteQueue = [];
    try {
        for (const epochMessageData of epochMessages) {
            const epoch = getFoundationModules().GroupSessionMessage.deserialize(epochMessageData);
            deleteQueue.push(epoch);
            session.addEpoch(epoch);
        }
        return session;
    }
    finally {
        while (deleteQueue.length) {
            const obj = deleteQueue.pop();
            obj && obj.delete();
        }
    }
}
function computeSessionId(groupId) {
    const sha512 = new (getFoundationModules()).Sha512();
    try {
        return sha512.hash(groupId).subarray(0, 32);
    }
    finally {
        sha512.delete();
    }
}
function createInitialEpoch(sessionId) {
    const ticket = new (getFoundationModules()).GroupSessionTicket();
    ticket.rng = getRandom();
    try {
        ticket.setupTicketAsNew(sessionId);
        return ticket.getTicketMessage();
    }
    finally {
        ticket.delete();
    }
}

function createVirgilGroupSession(epochMessages) {
    epochMessages = epochMessages
        .slice()
        .sort((a, b) => getEpochNumberFromEpochMessage(a) - getEpochNumberFromEpochMessage(b));
    return {
        getSessionId() {
            const session = createLowLevelSession(epochMessages);
            const id = session.getSessionId();
            session.delete();
            return toBuffer(id).toString('hex');
        },
        getCurrentEpochNumber() {
            return getEpochNumberFromEpochMessage(epochMessages[epochMessages.length - 1]);
        },
        encrypt(data, signingPrivateKey) {
            const dataBytes = dataToUint8Array(data, 'utf8');
            validatePrivateKey(signingPrivateKey);
            const lowLevelPrivateKey = getLowLevelPrivateKey(signingPrivateKey);
            let session;
            try {
                session = createLowLevelSession(epochMessages);
                const message = session.encrypt(dataBytes, lowLevelPrivateKey);
                const encrypted = message.serialize();
                message.delete();
                return toBuffer(encrypted);
            }
            finally {
                session && session.delete();
                lowLevelPrivateKey.delete();
            }
        },
        decrypt(encryptedData, verifyingPublicKey) {
            const encryptedDataBytes = dataToUint8Array(encryptedData, 'base64');
            validatePublicKey(verifyingPublicKey);
            const lowLevelPublicKey = importPublicKey(verifyingPublicKey.key);
            let session;
            let message;
            try {
                session = createLowLevelSession(epochMessages);
                message = getFoundationModules().GroupSessionMessage.deserialize(encryptedDataBytes);
                return toBuffer(session.decrypt(message, lowLevelPublicKey));
            }
            finally {
                message && message.delete();
                session && session.delete();
                lowLevelPublicKey.delete();
            }
        },
        addNewEpoch() {
            const session = createLowLevelSession(epochMessages);
            try {
                const newEpochTicket = session.createGroupTicket();
                const newEpoch = newEpochTicket.getTicketMessage();
                const newEpochMessage = newEpoch.serialize();
                epochMessages.push(newEpochMessage);
                newEpoch.delete();
                newEpochTicket.delete();
                return parseGroupSessionMessage(newEpochMessage);
            }
            finally {
                session.delete();
            }
        },
        export() {
            return epochMessages.map(toBuffer);
        },
        parseMessage(messageData) {
            const messageBytes = dataToUint8Array(messageData, 'base64');
            return parseGroupSessionMessage(messageBytes);
        },
    };
}

const MIN_GROUP_ID_BYTE_LENGTH = 10;
class VirgilCrypto {
    constructor(options = {}) {
        this.hashAlgorithm = HashAlgorithm;
        this.keyPairType = KeyPairType;
        this.foundationModules = getFoundationModules();
        this.random = new this.foundationModules.CtrDrbg();
        try {
            this.random.setupDefaults();
        }
        catch (error) {
            this.random.delete();
            throw error;
        }
        this.defaultKeyPairType = options.defaultKeyPairType || KeyPairType.Default;
        this.useSha256Identifiers = options.useSha256Identifiers || false;
    }
    generateKeys(type) {
        const keyPairType = type ? type : this.defaultKeyPairType;
        const keyProvider = new this.foundationModules.KeyProvider();
        try {
            keyProvider.setupDefaults();
        }
        catch (error) {
            keyProvider.delete();
            throw error;
        }
        if (keyPairType.algId === this.foundationModules.AlgId.RSA) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            keyProvider.setRsaParams(keyPairType.bitlen);
        }
        let lowLevelPrivateKey;
        try {
            lowLevelPrivateKey = keyProvider.generatePrivateKey(keyPairType.algId);
        }
        catch (error) {
            keyProvider.delete();
            throw error;
        }
        const lowLevelPublicKey = lowLevelPrivateKey.extractPublicKey();
        try {
            const serializedPublicKey = serializePublicKey(lowLevelPublicKey);
            const serializedPrivateKey = serializePrivateKey(lowLevelPrivateKey);
            const identifier = this.calculateKeypairIdentifier(serializedPublicKey, this.useSha256Identifiers);
            return {
                privateKey: new VirgilPrivateKey(identifier, serializedPrivateKey),
                publicKey: new VirgilPublicKey(identifier, serializedPublicKey),
            };
        }
        finally {
            keyProvider.delete();
            lowLevelPrivateKey.delete();
            lowLevelPublicKey.delete();
        }
    }
    generateKeysFromKeyMaterial(keyMaterial, type) {
        const keyPairType = type ? type : this.defaultKeyPairType;
        const myKeyMaterial = dataToUint8Array(keyMaterial, 'base64');
        const keyMaterialRng = new this.foundationModules.KeyMaterialRng();
        keyMaterialRng.resetKeyMaterial(myKeyMaterial);
        const keyProvider = new this.foundationModules.KeyProvider();
        try {
            keyProvider.setupDefaults();
        }
        catch (error) {
            keyMaterialRng.delete();
            keyProvider.delete();
            throw error;
        }
        keyProvider.random = keyMaterialRng;
        if (keyPairType.algId === this.foundationModules.AlgId.RSA) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            keyProvider.setRsaParams(keyPairType.bitlen);
        }
        let lowLevelPrivateKey;
        try {
            lowLevelPrivateKey = keyProvider.generatePrivateKey(keyPairType.algId);
        }
        catch (error) {
            keyMaterialRng.delete();
            keyProvider.delete();
            throw error;
        }
        const lowLevelPublicKey = lowLevelPrivateKey.extractPublicKey();
        try {
            const serializedPublicKey = serializePublicKey(lowLevelPublicKey);
            const serializedPrivateKey = serializePrivateKey(lowLevelPrivateKey);
            const identifier = this.calculateKeypairIdentifier(serializedPublicKey, this.useSha256Identifiers);
            return {
                privateKey: new VirgilPrivateKey(identifier, serializedPrivateKey),
                publicKey: new VirgilPublicKey(identifier, serializedPublicKey),
            };
        }
        finally {
            keyMaterialRng.delete();
            keyProvider.delete();
            lowLevelPrivateKey.delete();
            lowLevelPublicKey.delete();
        }
    }
    importPrivateKey(rawPrivateKey) {
        const serializedPrivateKey = dataToUint8Array(rawPrivateKey, 'base64');
        const lowLevelPrivateKey = importPrivateKey(serializedPrivateKey);
        const lowLevelPublicKey = lowLevelPrivateKey.extractPublicKey();
        try {
            const serializedPublicKey = serializePublicKey(lowLevelPublicKey);
            const identifier = this.calculateKeypairIdentifier(serializedPublicKey, this.useSha256Identifiers);
            return new VirgilPrivateKey(identifier, serializedPrivateKey);
        }
        finally {
            lowLevelPrivateKey.delete();
            lowLevelPublicKey.delete();
        }
    }
    exportPrivateKey(privateKey) {
        validatePrivateKey(privateKey);
        const lowLevelPrivateKey = getLowLevelPrivateKey(privateKey);
        try {
            const serializedPrivateKey = serializePrivateKey(lowLevelPrivateKey);
            return toBuffer(serializedPrivateKey);
        }
        finally {
            lowLevelPrivateKey.delete();
        }
    }
    importPublicKey(rawPublicKey) {
        const serializedPublicKey = dataToUint8Array(rawPublicKey, 'base64');
        const lowLevelPublicKey = importPublicKey(serializedPublicKey);
        const identifier = this.calculateKeypairIdentifier(serializedPublicKey, this.useSha256Identifiers);
        lowLevelPublicKey.delete();
        return new VirgilPublicKey(identifier, serializedPublicKey);
    }
    exportPublicKey(publicKey) {
        return toBuffer(publicKey.key);
    }
    encrypt(data, publicKey) {
        const myData = dataToUint8Array(data, 'utf8');
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        const lowLevelPublicKeys = getLowLevelPublicKeys(publicKeys);
        const recipientCipher = new this.foundationModules.RecipientCipher();
        const aes256Gcm = new this.foundationModules.Aes256Gcm();
        recipientCipher.encryptionCipher = aes256Gcm;
        recipientCipher.random = this.random;
        publicKeys.forEach(({ identifier }, index) => {
            recipientCipher.addKeyRecipient(identifier, lowLevelPublicKeys[index]);
        });
        try {
            recipientCipher.startEncryption();
            const messageInfo = recipientCipher.packMessageInfo();
            const processEncryption = recipientCipher.processEncryption(myData);
            const finishEncryption = recipientCipher.finishEncryption();
            return NodeBuffer.concat([messageInfo, processEncryption, finishEncryption]);
        }
        finally {
            recipientCipher.delete();
            aes256Gcm.delete();
            lowLevelPublicKeys.forEach(lowLevelPublicKey => lowLevelPublicKey.delete());
        }
    }
    decrypt(encryptedData, privateKey) {
        const myData = dataToUint8Array(encryptedData, 'base64');
        validatePrivateKey(privateKey);
        const lowLevelPrivateKey = getLowLevelPrivateKey(privateKey);
        const recipientCipher = new this.foundationModules.RecipientCipher();
        recipientCipher.random = this.random;
        try {
            recipientCipher.startDecryptionWithKey(privateKey.identifier, lowLevelPrivateKey, new Uint8Array(0));
            const processDecryption = recipientCipher.processDecryption(myData);
            const finishDecryption = recipientCipher.finishDecryption();
            return NodeBuffer.concat([processDecryption, finishDecryption]);
        }
        finally {
            lowLevelPrivateKey.delete();
            recipientCipher.delete();
        }
    }
    calculateHash(data, algorithm = HashAlgorithm.SHA512) {
        const myData = dataToUint8Array(data, 'utf8');
        let result;
        switch (algorithm) {
            case HashAlgorithm.SHA224:
                result = this.createHash(myData, this.foundationModules.Sha224);
                break;
            case HashAlgorithm.SHA256:
                result = this.createHash(myData, this.foundationModules.Sha256);
                break;
            case HashAlgorithm.SHA384:
                result = this.createHash(myData, this.foundationModules.Sha384);
                break;
            case HashAlgorithm.SHA512:
                result = this.createHash(myData, this.foundationModules.Sha512);
                break;
            default:
                throw new TypeError('Unknown hash algorithm');
        }
        return toBuffer(result);
    }
    extractPublicKey(privateKey) {
        validatePrivateKey(privateKey);
        const lowLevelPrivateKey = getLowLevelPrivateKey(privateKey);
        const lowLevelPublicKey = lowLevelPrivateKey.extractPublicKey();
        try {
            const serializedPublicKey = serializePublicKey(lowLevelPublicKey);
            return new VirgilPublicKey(privateKey.identifier, serializedPublicKey);
        }
        finally {
            lowLevelPrivateKey.delete();
            lowLevelPublicKey.delete();
        }
    }
    calculateSignature(data, privateKey) {
        const myData = dataToUint8Array(data, 'utf8');
        validatePrivateKey(privateKey);
        const lowLevelPrivateKey = getLowLevelPrivateKey(privateKey);
        const signer = new this.foundationModules.Signer();
        const sha512 = new this.foundationModules.Sha512();
        signer.hash = sha512;
        signer.reset();
        signer.appendData(myData);
        try {
            const signature = signer.sign(lowLevelPrivateKey);
            return toBuffer(signature);
        }
        finally {
            signer.delete();
            sha512.delete();
            lowLevelPrivateKey.delete();
        }
    }
    verifySignature(data, signature, publicKey) {
        const myData = dataToUint8Array(data, 'utf8');
        const mySignature = dataToUint8Array(signature, 'base64');
        validatePublicKey(publicKey);
        const lowLevelPublicKey = importPublicKey(publicKey.key);
        const verifier = new this.foundationModules.Verifier();
        try {
            verifier.reset(mySignature);
        }
        catch (error) {
            lowLevelPublicKey.delete();
            verifier.delete();
            throw error;
        }
        verifier.appendData(myData);
        const result = verifier.verify(lowLevelPublicKey);
        verifier.delete();
        lowLevelPublicKey.delete();
        return result;
    }
    signThenEncrypt(data, privateKey, publicKey) {
        const myData = dataToUint8Array(data, 'utf8');
        validatePrivateKey(privateKey);
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        const lowLevelPublicKeys = getLowLevelPublicKeys(publicKeys);
        const recipientCipher = new this.foundationModules.RecipientCipher();
        const aes256Gcm = new this.foundationModules.Aes256Gcm();
        recipientCipher.encryptionCipher = aes256Gcm;
        recipientCipher.random = this.random;
        publicKeys.forEach(({ identifier }, index) => {
            recipientCipher.addKeyRecipient(identifier, lowLevelPublicKeys[index]);
        });
        const messageInfoCustomParams = recipientCipher.customParams();
        try {
            const signature = this.calculateSignature(myData, privateKey);
            messageInfoCustomParams.addData(DATA_SIGNATURE_KEY, signature);
            messageInfoCustomParams.addData(DATA_SIGNER_ID_KEY, privateKey.identifier);
            recipientCipher.startEncryption();
            const messageInfo = recipientCipher.packMessageInfo();
            const processEncryption = recipientCipher.processEncryption(myData);
            const finishEncryption = recipientCipher.finishEncryption();
            return NodeBuffer.concat([messageInfo, processEncryption, finishEncryption]);
        }
        finally {
            lowLevelPublicKeys.forEach(lowLevelPublicKey => lowLevelPublicKey.delete());
            recipientCipher.delete();
            aes256Gcm.delete();
            messageInfoCustomParams.delete();
        }
    }
    decryptThenVerify(encryptedData, privateKey, publicKey) {
        const myEncryptedData = dataToUint8Array(encryptedData, 'base64');
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        validatePrivateKey(privateKey);
        const lowLevelPrivateKey = getLowLevelPrivateKey(privateKey);
        const recipientCipher = new this.foundationModules.RecipientCipher();
        recipientCipher.random = this.random;
        let decryptedData;
        try {
            recipientCipher.startDecryptionWithKey(privateKey.identifier, lowLevelPrivateKey, new Uint8Array(0));
            const processDecryption = recipientCipher.processDecryption(myEncryptedData);
            const finishDecryption = recipientCipher.finishDecryption();
            decryptedData = NodeBuffer.concat([processDecryption, finishDecryption]);
        }
        catch (error) {
            lowLevelPrivateKey.delete();
            recipientCipher.delete();
            throw error;
        }
        const messageInfoCustomParams = recipientCipher.customParams();
        let signerPublicKey;
        if (publicKeys.length === 1) {
            signerPublicKey = publicKeys[0];
        }
        else {
            let signerId;
            try {
                signerId = messageInfoCustomParams.findData(DATA_SIGNER_ID_KEY);
            }
            catch (error) {
                lowLevelPrivateKey.delete();
                recipientCipher.delete();
                messageInfoCustomParams.delete();
                throw error;
            }
            for (let i = 0; i < publicKeys.length; i += 1) {
                if (NodeBuffer.compare(signerId, publicKeys[i].identifier) === 0) {
                    signerPublicKey = publicKeys[i];
                    break;
                }
            }
            if (!signerPublicKey) {
                lowLevelPrivateKey.delete();
                recipientCipher.delete();
                messageInfoCustomParams.delete();
                throw new Error('Signer not found');
            }
        }
        try {
            const signature = messageInfoCustomParams.findData(DATA_SIGNATURE_KEY);
            const isValid = this.verifySignature(decryptedData, signature, signerPublicKey);
            if (!isValid) {
                throw new Error('Invalid signature');
            }
            return decryptedData;
        }
        finally {
            lowLevelPrivateKey.delete();
            recipientCipher.delete();
            messageInfoCustomParams.delete();
        }
    }
    getRandomBytes(length) {
        const bytes = this.random.random(length);
        return toBuffer(bytes);
    }
    signThenEncryptDetached(data, privateKey, publicKey) {
        const myData = dataToUint8Array(data, 'utf8');
        validatePrivateKey(privateKey);
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        const lowLevelPublicKeys = getLowLevelPublicKeys(publicKeys);
        const recipientCipher = new this.foundationModules.RecipientCipher();
        const aes256Gcm = new this.foundationModules.Aes256Gcm();
        recipientCipher.encryptionCipher = aes256Gcm;
        recipientCipher.random = this.random;
        publicKeys.forEach(({ identifier }, index) => {
            recipientCipher.addKeyRecipient(identifier, lowLevelPublicKeys[index]);
        });
        const messageInfoCustomParams = recipientCipher.customParams();
        try {
            const signature = this.calculateSignature(myData, privateKey);
            messageInfoCustomParams.addData(DATA_SIGNATURE_KEY, signature);
            messageInfoCustomParams.addData(DATA_SIGNER_ID_KEY, privateKey.identifier);
            recipientCipher.startEncryption();
            const messageInfo = recipientCipher.packMessageInfo();
            const processEncryption = recipientCipher.processEncryption(myData);
            const finishEncryption = recipientCipher.finishEncryption();
            const encryptedData = NodeBuffer.concat([processEncryption, finishEncryption]);
            const metadata = toBuffer(messageInfo);
            return { encryptedData, metadata };
        }
        finally {
            lowLevelPublicKeys.forEach(lowLevelPublicKey => lowLevelPublicKey.delete());
            recipientCipher.delete();
            aes256Gcm.delete();
            messageInfoCustomParams.delete();
        }
    }
    decryptThenVerifyDetached(encryptedData, metadata, privateKey, publicKey) {
        const myEncryptedData = dataToUint8Array(encryptedData, 'base64');
        const myMetadata = dataToUint8Array(metadata, 'base64');
        validatePrivateKey(privateKey);
        const lowLevelPrivateKey = getLowLevelPrivateKey(privateKey);
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        const recipientCipher = new this.foundationModules.RecipientCipher();
        recipientCipher.random = this.random;
        let decryptedData;
        try {
            recipientCipher.startDecryptionWithKey(privateKey.identifier, lowLevelPrivateKey, myMetadata);
            const processDecryption = recipientCipher.processDecryption(myEncryptedData);
            const finishDecryption = recipientCipher.finishDecryption();
            decryptedData = NodeBuffer.concat([processDecryption, finishDecryption]);
        }
        catch (error) {
            lowLevelPrivateKey.delete();
            recipientCipher.delete();
            throw error;
        }
        const messageInfoCustomParams = recipientCipher.customParams();
        let signerPublicKey;
        if (publicKeys.length === 1) {
            signerPublicKey = publicKeys[0];
        }
        else {
            let signerId;
            try {
                signerId = messageInfoCustomParams.findData(DATA_SIGNER_ID_KEY);
            }
            catch (error) {
                lowLevelPrivateKey.delete();
                recipientCipher.delete();
                messageInfoCustomParams.delete();
                throw error;
            }
            for (let i = 0; i < publicKeys.length; i += 1) {
                if (NodeBuffer.compare(signerId, publicKeys[i].identifier) === 0) {
                    signerPublicKey = publicKeys[i];
                    break;
                }
            }
            if (!signerPublicKey) {
                lowLevelPrivateKey.delete();
                recipientCipher.delete();
                messageInfoCustomParams.delete();
                throw new Error('Signer not found');
            }
        }
        try {
            const signature = messageInfoCustomParams.findData(DATA_SIGNATURE_KEY);
            const isValid = this.verifySignature(decryptedData, signature, signerPublicKey);
            if (!isValid) {
                throw new Error('Invalid signature');
            }
            return decryptedData;
        }
        finally {
            lowLevelPrivateKey.delete();
            recipientCipher.delete();
            messageInfoCustomParams.delete();
        }
    }
    createStreamCipher(publicKey, signature) {
        return new VirgilStreamCipher(publicKey, signature);
    }
    createStreamDecipher(privateKey) {
        return new VirgilStreamDecipher(privateKey);
    }
    createStreamSigner() {
        return new VirgilStreamSigner();
    }
    createStreamVerifier(signature) {
        return new VirgilStreamVerifier(signature);
    }
    generateGroupSession(groupId) {
        const groupIdBytes = dataToUint8Array(groupId, 'utf8');
        this.validateGroupId(groupIdBytes);
        const sessionId = computeSessionId(groupIdBytes);
        const initialEpoch = createInitialEpoch(sessionId);
        const initialEpochMessage = initialEpoch.serialize();
        initialEpoch.delete();
        return createVirgilGroupSession([initialEpochMessage]);
    }
    importGroupSession(epochMessages) {
        if (!Array.isArray(epochMessages)) {
            throw new TypeError('Epoch messages must be an array.');
        }
        if (epochMessages.length === 0) {
            throw new Error('Epoch messages must not be empty.');
        }
        return createVirgilGroupSession(epochMessages.map(it => dataToUint8Array(it, 'base64')));
    }
    calculateGroupSessionId(groupId) {
        const groupIdBytes = dataToUint8Array(groupId, 'utf8');
        this.validateGroupId(groupIdBytes);
        return toBuffer(computeSessionId(groupIdBytes)).toString('hex');
    }
    validateGroupId(groupId) {
        if (groupId.byteLength < MIN_GROUP_ID_BYTE_LENGTH) {
            throw new Error(`The given group Id is too short. Must be at least ${MIN_GROUP_ID_BYTE_LENGTH} bytes.`);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    createHash(data, HashClass) {
        const hashInstance = new HashClass();
        const hash = hashInstance.hash(data);
        hashInstance.delete();
        return hash;
    }
    calculateKeypairIdentifier(serializedPublicKey, useSha256Identifiers) {
        if (useSha256Identifiers) {
            return this.createHash(serializedPublicKey, this.foundationModules.Sha256);
        }
        return this.createHash(serializedPublicKey, this.foundationModules.Sha512).slice(0, 8);
    }
}

export { HashAlgorithm, KeyPairType, VirgilCrypto, VirgilPrivateKey, VirgilPublicKey, VirgilStreamCipher, VirgilStreamDecipher, VirgilStreamSigner, VirgilStreamVerifier, getFoundationModules, hasFoundationModules, setFoundationModules };
