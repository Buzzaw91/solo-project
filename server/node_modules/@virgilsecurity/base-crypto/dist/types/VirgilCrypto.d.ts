/// <reference types="node" />
import { HashAlgorithmType } from './HashAlgorithm';
import { KeyPairTypeType } from './KeyPairType';
import { ICrypto, Data, IGroupSession } from './types';
import { VirgilPrivateKey } from './VirgilPrivateKey';
import { VirgilPublicKey } from './VirgilPublicKey';
import { VirgilStreamCipher } from './VirgilStreamCipher';
import { VirgilStreamDecipher } from './VirgilStreamDecipher';
import { VirgilStreamSigner } from './VirgilStreamSigner';
import { VirgilStreamVerifier } from './VirgilStreamVerifier';
export declare const MIN_GROUP_ID_BYTE_LENGTH = 10;
export interface VirgilCryptoOptions {
    useSha256Identifiers?: boolean;
    defaultKeyPairType?: KeyPairTypeType[keyof KeyPairTypeType];
}
export declare class VirgilCrypto implements ICrypto {
    readonly useSha256Identifiers: boolean;
    readonly defaultKeyPairType: KeyPairTypeType[keyof KeyPairTypeType];
    readonly hashAlgorithm: HashAlgorithmType;
    readonly keyPairType: KeyPairTypeType;
    private foundationModules;
    private random;
    constructor(options?: VirgilCryptoOptions);
    generateKeys(type?: KeyPairTypeType[keyof KeyPairTypeType]): {
        privateKey: VirgilPrivateKey;
        publicKey: VirgilPublicKey;
    };
    generateKeysFromKeyMaterial(keyMaterial: Data, type?: KeyPairTypeType[keyof KeyPairTypeType]): {
        privateKey: VirgilPrivateKey;
        publicKey: VirgilPublicKey;
    };
    importPrivateKey(rawPrivateKey: Data): VirgilPrivateKey;
    exportPrivateKey(privateKey: VirgilPrivateKey): Buffer;
    importPublicKey(rawPublicKey: Data): VirgilPublicKey;
    exportPublicKey(publicKey: VirgilPublicKey): Buffer;
    encrypt(data: Data, publicKey: VirgilPublicKey | VirgilPublicKey[]): Buffer;
    decrypt(encryptedData: Data, privateKey: VirgilPrivateKey): Buffer;
    calculateHash(data: Data, algorithm?: HashAlgorithmType[keyof HashAlgorithmType]): Buffer;
    extractPublicKey(privateKey: VirgilPrivateKey): VirgilPublicKey;
    calculateSignature(data: Data, privateKey: VirgilPrivateKey): Buffer;
    verifySignature(data: Data, signature: Data, publicKey: VirgilPublicKey): boolean;
    signThenEncrypt(data: Data, privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey | VirgilPublicKey[]): Buffer;
    decryptThenVerify(encryptedData: Data, privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey | VirgilPublicKey[]): Buffer;
    getRandomBytes(length: number): Buffer;
    signThenEncryptDetached(data: Data, privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey | VirgilPublicKey[]): {
        encryptedData: Buffer;
        metadata: Buffer;
    };
    decryptThenVerifyDetached(encryptedData: Data, metadata: Data, privateKey: VirgilPrivateKey, publicKey: VirgilPublicKey | VirgilPublicKey[]): Buffer;
    createStreamCipher(publicKey: VirgilPublicKey | VirgilPublicKey[], signature?: Data): VirgilStreamCipher;
    createStreamDecipher(privateKey: VirgilPrivateKey): VirgilStreamDecipher;
    createStreamSigner(): VirgilStreamSigner;
    createStreamVerifier(signature: Data): VirgilStreamVerifier;
    generateGroupSession(groupId: Data): IGroupSession;
    importGroupSession(epochMessages: Data[]): IGroupSession;
    calculateGroupSessionId(groupId: Data): string;
    private validateGroupId;
    private createHash;
    private calculateKeypairIdentifier;
}
