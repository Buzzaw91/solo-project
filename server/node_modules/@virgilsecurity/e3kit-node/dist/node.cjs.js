/**
 * BSD 3-Clause License
 *
 * Copyright (c) 2018-2019, Virgil Security, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var e3kitBase = require('@virgilsecurity/e3kit-base');
var baseCrypto = require('@virgilsecurity/base-crypto');
var initFoundation = _interopDefault(require('@virgilsecurity/core-foundation/node.cjs.js'));
var node_cjs_js = require('@virgilsecurity/pythia-crypto/dist/node.cjs.js');
var sdkCrypto = require('@virgilsecurity/sdk-crypto');
var virgilSdk = require('virgil-sdk');
var leveldown = _interopDefault(require('leveldown'));
var isInvalidPath = _interopDefault(require('is-invalid-path'));
var mkdirp = _interopDefault(require('mkdirp'));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/// <reference path="index.d.ts" />
class EThree extends e3kitBase.AbstractEThree {
    /**
     * @hidden
     * @param identity - Identity of the current user.
     */
    constructor(identity, options) {
        const opts = Object.assign({ apiUrl: e3kitBase.DEFAULT_API_URL, storageName: e3kitBase.DEFAULT_STORAGE_NAME, groupStorageName: e3kitBase.DEFAULT_GROUP_STORAGE_NAME, useSha256Identifiers: false }, options);
        const accessTokenProvider = opts.accessTokenProvider;
        const keyEntryStorage = opts.keyEntryStorage || new virgilSdk.KeyEntryStorage(opts.storageName);
        const virgilCrypto = new baseCrypto.VirgilCrypto({ useSha256Identifiers: opts.useSha256Identifiers });
        const cardCrypto = new sdkCrypto.VirgilCardCrypto(virgilCrypto);
        const brainKeyCrypto = new node_cjs_js.VirgilBrainKeyCrypto();
        const cardVerifier = new virgilSdk.VirgilCardVerifier(cardCrypto, {
            verifySelfSignature: opts.apiUrl === e3kitBase.DEFAULT_API_URL,
            verifyVirgilSignature: opts.apiUrl === e3kitBase.DEFAULT_API_URL,
        });
        const keyLoader = new e3kitBase.PrivateKeyLoader(identity, {
            accessTokenProvider,
            virgilCrypto,
            brainKeyCrypto,
            keyEntryStorage,
            apiUrl: opts.apiUrl,
        });
        const cardManager = new virgilSdk.CardManager({
            cardCrypto,
            cardVerifier,
            accessTokenProvider,
            retryOnUnauthorized: true,
            apiUrl: opts.apiUrl,
            productInfo: {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                product: "e3kit",
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                version: "0.7.0-beta.2",
            },
        });
        if (isInvalidPath(opts.groupStorageName)) {
            throw new TypeError('`groupStorageName` is not a valid path');
        }
        mkdirp.sync(opts.groupStorageName);
        const groupStorageLeveldown = leveldown(opts.groupStorageName);
        super({
            identity,
            virgilCrypto,
            cardManager,
            accessTokenProvider,
            keyEntryStorage,
            keyLoader,
            groupStorageLeveldown,
        });
    }
    /**
     * Initialize a new instance of EThree which tied to specific user.
     * @param getToken - Function that receive JWT.
     */
    static initialize(getToken, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const modulesToLoad = [];
            if (!baseCrypto.hasFoundationModules()) {
                modulesToLoad.push(initFoundation().then(baseCrypto.setFoundationModules));
            }
            if (!node_cjs_js.hasPythiaModules()) {
                modulesToLoad.push(node_cjs_js.initPythia());
            }
            yield Promise.all(modulesToLoad);
            if (typeof getToken !== 'function') {
                throw new TypeError(`EThree.initialize expects a function that returns Virgil JWT, got ${typeof getToken}`);
            }
            const opts = Object.assign({ accessTokenProvider: new virgilSdk.CachingJwtProvider(getToken) }, options);
            const token = yield opts.accessTokenProvider.getToken({
                service: 'cards',
                operation: '',
            });
            const identity = token.identity();
            return new EThree(identity, opts);
        });
    }
    /**
     * @hidden
     */
    isPublicKey(publicKey) {
        return publicKey instanceof baseCrypto.VirgilPublicKey;
    }
}

Object.defineProperty(exports, 'AbortError', {
    enumerable: true,
    get: function () {
        return e3kitBase.AbortError;
    }
});
Object.defineProperty(exports, 'GroupError', {
    enumerable: true,
    get: function () {
        return e3kitBase.GroupError;
    }
});
Object.defineProperty(exports, 'GroupErrorCode', {
    enumerable: true,
    get: function () {
        return e3kitBase.GroupErrorCode;
    }
});
Object.defineProperty(exports, 'IdentityAlreadyExistsError', {
    enumerable: true,
    get: function () {
        return e3kitBase.IdentityAlreadyExistsError;
    }
});
Object.defineProperty(exports, 'IntegrityCheckFailedError', {
    enumerable: true,
    get: function () {
        return e3kitBase.IntegrityCheckFailedError;
    }
});
Object.defineProperty(exports, 'LookupError', {
    enumerable: true,
    get: function () {
        return e3kitBase.LookupError;
    }
});
Object.defineProperty(exports, 'LookupNotFoundError', {
    enumerable: true,
    get: function () {
        return e3kitBase.LookupNotFoundError;
    }
});
Object.defineProperty(exports, 'MissingPrivateKeyError', {
    enumerable: true,
    get: function () {
        return e3kitBase.MissingPrivateKeyError;
    }
});
Object.defineProperty(exports, 'MultipleCardsError', {
    enumerable: true,
    get: function () {
        return e3kitBase.MultipleCardsError;
    }
});
Object.defineProperty(exports, 'PrivateKeyAlreadyExistsError', {
    enumerable: true,
    get: function () {
        return e3kitBase.PrivateKeyAlreadyExistsError;
    }
});
Object.defineProperty(exports, 'PrivateKeyNoBackupError', {
    enumerable: true,
    get: function () {
        return e3kitBase.PrivateKeyNoBackupError;
    }
});
Object.defineProperty(exports, 'RegisterRequiredError', {
    enumerable: true,
    get: function () {
        return e3kitBase.RegisterRequiredError;
    }
});
Object.defineProperty(exports, 'SdkError', {
    enumerable: true,
    get: function () {
        return e3kitBase.SdkError;
    }
});
Object.defineProperty(exports, 'WrongKeyknoxPasswordError', {
    enumerable: true,
    get: function () {
        return e3kitBase.WrongKeyknoxPasswordError;
    }
});
exports.EThree = EThree;
