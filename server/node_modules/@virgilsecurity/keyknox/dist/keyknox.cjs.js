"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var axios=_interopDefault(require("axios")),virgilSdk=require("virgil-sdk"),base64=_interopDefault(require("base-64"));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function __rest(e,t){var r={};for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&t.indexOf(i)<0&&(r[i]=e[i]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(i=Object.getOwnPropertySymbols(e);o<i.length;o++)t.indexOf(i[o])<0&&(r[i[o]]=e[i[o]])}return r}function __awaiter(e,t,r,i){return new(r||(r=Promise))((function(o,n){function s(e){try{y(i.next(e))}catch(e){n(e)}}function a(e){try{y(i.throw(e))}catch(e){n(e)}}function y(e){e.done?o(e.value):new r((function(t){t(e.value)})).then(s,a)}y((i=i.apply(e,t||[])).next())}))}class KeyknoxError extends Error{constructor(e,t="KeyknoxError",r=KeyknoxError){super(e),Object.setPrototypeOf(this,r.prototype),this.name=t}}class KeyknoxClientError extends KeyknoxError{constructor(e,t,r){super(e,"KeyknoxClientError",KeyknoxClientError),this.status=t,this.code=r}}class CloudKeyStorageOutOfSyncError extends KeyknoxError{constructor(){super("CloudKeyStorage is out of sync","CloudKeyStorageOutOfSyncError",CloudKeyStorageOutOfSyncError)}}class CloudEntryExistsError extends KeyknoxError{constructor(e){super(`Cloud entry '${e}' already exists`,"CloudEntryExistsError",CloudEntryExistsError),this.cloudEntryName=e}}class CloudEntryDoesntExistError extends KeyknoxError{constructor(e){super(`Cloud entry '${e}' doesn't exist`,"CloudEntryDoesntExistError",CloudEntryDoesntExistError),this.cloudEntryName=e}}class KeyEntryExistsError extends KeyknoxError{constructor(e){super(`Key entry '${e}' already exists`,"KeyEntryExistsError",KeyEntryExistsError),this.keyEntryName=e}}class KeyEntryDoesntExistError extends KeyknoxError{constructor(e){super(`Key entry '${e}' doesn't exist`,"KeyEntryDoesntExistError",KeyEntryDoesntExistError),this.keyEntryName=e}}class GroupTicketAlreadyExistsError extends KeyknoxError{constructor(){super("GroupSessionMessageInfo already exist","GroupTicketAlreadyExistsError",GroupTicketAlreadyExistsError)}}class GroupTicketDoesntExistError extends KeyknoxError{constructor(){super("Group ticket doesn't exist","GroupTicketDoesntExistError",GroupTicketDoesntExistError)}}class GroupTicketNoAccessError extends KeyknoxError{constructor(){super("Current user has no access to the group ticket","GroupTicketNoAccessError",GroupTicketNoAccessError)}}class KeyknoxClient{constructor(e,t,r,i){this.accessTokenProvider=e,this.axios=r||axios.create({baseURL:t||KeyknoxClient.API_URL}),this.virgilAgent=i||new virgilSdk.VirgilAgent("keyknox","0.4.0-next.3"),this.axios.interceptors.response.use(void 0,KeyknoxClient.responseErrorHandler)}v1Push(e,t,r){return __awaiter(this,void 0,void 0,(function*(){const i={meta:e,value:t},o=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"put"}),n={headers:KeyknoxClient.getHeaders({accessToken:o,keyknoxHash:r,virgilAgent:this.virgilAgent})},s=yield this.axios.put("/keyknox/v1",i,n);return KeyknoxClient.getKeyknoxValueV1(s)}))}v1Pull(){return __awaiter(this,void 0,void 0,(function*(){const e=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"get"}),t={headers:KeyknoxClient.getHeaders({accessToken:e,virgilAgent:this.virgilAgent})},r=yield this.axios.get("/keyknox/v1",t);return KeyknoxClient.getKeyknoxValueV1(r)}))}v1Reset(){return __awaiter(this,void 0,void 0,(function*(){const e=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"delete"}),t={headers:KeyknoxClient.getHeaders({accessToken:e,virgilAgent:this.virgilAgent})},r=yield this.axios.post("/keyknox/v1/reset",void 0,t);return KeyknoxClient.getKeyknoxValueV1(r)}))}v2Push(e){return __awaiter(this,void 0,void 0,(function*(){const{root:t,path:r,key:i,identities:o,meta:n,value:s,keyknoxHash:a}=e,y={root:t,path:r,key:i,identities:o,meta:n,value:s},c=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"put"}),d={headers:KeyknoxClient.getHeaders({accessToken:c,keyknoxHash:a,virgilAgent:this.virgilAgent})},u=yield this.axios.post("/keyknox/v2/push",y,d);return KeyknoxClient.getKeyknoxValueV2(u)}))}v2Pull(e){return __awaiter(this,void 0,void 0,(function*(){const{root:t,path:r,key:i,identity:o}=e,n={root:t,path:r,key:i,identity:o},s=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"get"}),a={headers:KeyknoxClient.getHeaders({accessToken:s,virgilAgent:this.virgilAgent})},y=yield this.axios.post("/keyknox/v2/pull",n,a);return KeyknoxClient.getKeyknoxValueV2(y)}))}v2GetKeys(e){return __awaiter(this,void 0,void 0,(function*(){const{root:t,path:r,identity:i}=e,o={root:t,path:r,identity:i},n=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"get"}),s={headers:KeyknoxClient.getHeaders({accessToken:n,virgilAgent:this.virgilAgent})};return(yield this.axios.post("/keyknox/v2/keys",o,s)).data}))}v2Reset(e){return __awaiter(this,void 0,void 0,(function*(){const{root:t,path:r,key:i,identity:o}=e,n={root:t,path:r,key:i,identity:o},s=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"delete"}),a={headers:KeyknoxClient.getHeaders({accessToken:s,virgilAgent:this.virgilAgent})},y=yield this.axios.post("/keyknox/v2/reset",n,a);return KeyknoxClient.getKeyknoxValueV2(y)}))}static getKeyknoxValueV1(e){const{data:t,headers:r}=e;return{meta:t.meta,value:t.value,version:t.version,keyknoxHash:r["virgil-keyknox-hash"]}}static getKeyknoxValueV2(e){const{data:t,headers:r}=e;return{owner:t.owner,root:t.root,path:t.path,key:t.key,identities:t.identities,meta:t.meta,value:t.value,keyknoxHash:r["virgil-keyknox-hash"]}}static getHeaders(e){const{virgilAgent:t,accessToken:r,keyknoxHash:i}=e,o={"Virgil-Agent":t.value};return r&&(o.Authorization=`Virgil ${r.toString()}`),i&&(o["Virgil-Keyknox-Previous-Hash"]=i),o}static responseErrorHandler(e){const{response:t}=e;if(t){const{data:r}=t;return r&&r.code&&r.message?Promise.reject(new KeyknoxClientError(r.message,t.status,r.code)):Promise.reject(new KeyknoxClientError(e.message,t.status))}return Promise.reject(new KeyknoxClientError(e.message))}}KeyknoxClient.API_URL="https://api.virgilsecurity.com";class KeyknoxCrypto{constructor(e){this.crypto=e}decrypt(e,t,r,i){if(!t||!e){if(t||e)throw new TypeError("'metadata' or 'encryptedData' is empty");return t}return this.crypto.decryptThenVerifyDetached({value:t,encoding:"base64"},{value:e,encoding:"base64"},r,i).toString("base64")}encrypt(e,t,r){const{metadata:i,encryptedData:o}=this.crypto.signThenEncryptDetached({value:e,encoding:"base64"},t,r);return{metadata:i.toString("base64"),encryptedData:o.toString("base64")}}}const ERROR_CODE_INVALID_PREVIOUS_HASH=50010;class KeyknoxManager{constructor(e,t){this.myKeyknoxCrypto=e,this.keyknoxClient=t}get keyknoxCrypto(){return this.myKeyknoxCrypto}static create(e,t){const r=new KeyknoxClient(e);return new KeyknoxManager(t,r)}v1Push(e,t,r,i){return __awaiter(this,void 0,void 0,(function*(){const{metadata:o,encryptedData:n}=this.myKeyknoxCrypto.encrypt(e,t,r),s=yield this.keyknoxClient.v1Push(o,n,i);return this.v1Decrypt(s,t,r)}))}v1Pull(e,t){return __awaiter(this,void 0,void 0,(function*(){const r=yield this.keyknoxClient.v1Pull();return this.v1Decrypt(r,e,t)}))}v1Reset(){return __awaiter(this,void 0,void 0,(function*(){return this.keyknoxClient.v1Reset()}))}v1Update(e){return __awaiter(this,void 0,void 0,(function*(){const{value:t,privateKey:r,publicKeys:i,keyknoxHash:o,newPrivateKey:n,newPublicKeys:s}=e;if(!n&&!s)return this.v1Push(t,r,i,o);const a=yield this.v1Pull(r,i),y=n||r,c=s||i,{metadata:d,encryptedData:u}=this.myKeyknoxCrypto.encrypt(a.value,y,c),l=yield this.keyknoxClient.v1Push(d,u,a.keyknoxHash);return this.v1Decrypt(l,y,c)}))}v1UpdateRecipients(e){return __awaiter(this,void 0,void 0,(function*(){const{privateKey:t,publicKeys:r,newPrivateKey:i,newPublicKeys:o}=e,n=yield this.v1Pull(t,r);if(!n.meta&&!n.value)return n;const s=i||t,a=o||r,{metadata:y,encryptedData:c}=this.myKeyknoxCrypto.encrypt(n.value,s,a),d=yield this.keyknoxClient.v1Push(y,c,n.keyknoxHash);return this.v1Decrypt(d,s,a)}))}v2Push(e){return __awaiter(this,void 0,void 0,(function*(){const{value:t,privateKey:r,publicKeys:i}=e,o=__rest(e,["value","privateKey","publicKeys"]),{metadata:n,encryptedData:s}=this.encrypt(t,r,i),a=yield this.keyknoxClient.v2Push(Object.assign(Object.assign({},o),{value:s,meta:n}));return this.v2Decrypt(a,r,i)}))}v2Pull(e){return __awaiter(this,void 0,void 0,(function*(){const{privateKey:t,publicKeys:r}=e,i=__rest(e,["privateKey","publicKeys"]),o=yield this.keyknoxClient.v2Pull(i);return this.v2Decrypt(o,t,r)}))}v2GetKeys(e){return __awaiter(this,void 0,void 0,(function*(){return this.keyknoxClient.v2GetKeys(e)}))}v2Reset(e){return __awaiter(this,void 0,void 0,(function*(){return this.keyknoxClient.v2Reset(e)}))}v1Decrypt(e,t,r){const{meta:i,value:o}=e,n=__rest(e,["meta","value"]),s=this.myKeyknoxCrypto.decrypt(i,o,t,r);return Object.assign(Object.assign({},n),{meta:i,value:s})}v2Decrypt(e,t,r){const{meta:i,value:o}=e,n=__rest(e,["meta","value"]),s=this.myKeyknoxCrypto.decrypt(i,o,t,r);return Object.assign(Object.assign({},n),{meta:i,value:s})}encrypt(e,t,r){return this.myKeyknoxCrypto.encrypt(e,t,r)}}class CloudGroupTicketStorage{constructor(e){const{keyknoxManager:t,identity:r,privateKey:i,publicKey:o,root:n}=e;this.keyknoxManager=t,this.identity=r,this.privateKey=i,this.publicKey=o,this.root=n||CloudGroupTicketStorage.DEFAULT_ROOT}static create(e){const{accessTokenProvider:t,identity:r,privateKey:i,publicKey:o,virgilCrypto:n,root:s}=e,a=KeyknoxManager.create(t,new KeyknoxCrypto(n));return new CloudGroupTicketStorage({keyknoxManager:a,identity:r,privateKey:i,publicKey:o,root:s})}store(e,t){return __awaiter(this,void 0,void 0,(function*(){const{epochNumber:r,sessionId:i,data:o}=e;let n=[this.identity],s=[this.publicKey];if(t){const e=Array.isArray(t)?t:[t];n=n.concat(e.map(e=>e.identity)),s=s.concat(e.map(e=>e.publicKey))}try{yield this.keyknoxManager.v2Push({identities:n,publicKeys:s,privateKey:this.privateKey,root:this.root,path:i,key:r.toString(),value:o})}catch(e){if(e instanceof KeyknoxClientError&&e.code===ERROR_CODE_INVALID_PREVIOUS_HASH)throw new GroupTicketAlreadyExistsError;throw e}}))}retrieve(e,t,r){return __awaiter(this,void 0,void 0,(function*(){let i=this.identity,o=this.publicKey;if(t&&r)i=t,o=r;else if(Boolean(t)!==Boolean(r))throw new Error("You need to provide both 'identity' and 'publicKey'");const n=yield this.keyknoxManager.v2GetKeys({root:this.root,path:e,identity:i});if(!n.length)throw new GroupTicketDoesntExistError;const s=n.map(t=>this.keyknoxManager.v2Pull({root:this.root,path:e,key:t,identity:i,privateKey:this.privateKey,publicKeys:o}));try{return(yield Promise.all(s)).map(({key:e,path:t,identities:r,value:i})=>({identities:r,groupSessionMessageInfo:{sessionId:t,epochNumber:Number(e),data:i}}))}catch(e){throw CloudGroupTicketStorage.throwIfRecipientIsNotFound(e),e}}))}addRecipients(e,t){return __awaiter(this,void 0,void 0,(function*(){const r=(yield this.keyknoxManager.v2GetKeys({root:this.root,path:e,identity:this.identity})).map(r=>__awaiter(this,void 0,void 0,(function*(){const i=yield this.keyknoxManager.v2Pull({root:this.root,path:e,key:r,identity:this.identity,privateKey:this.privateKey,publicKeys:this.publicKey});yield this.keyknoxManager.v2Push(Object.assign(Object.assign({},i),{identities:t.map(e=>e.identity),publicKeys:[this.publicKey,...t.map(e=>e.publicKey)],privateKey:this.privateKey}))})));try{yield Promise.all(r)}catch(e){throw CloudGroupTicketStorage.throwIfRecipientIsNotFound(e),e}}))}addRecipient(e,t){return __awaiter(this,void 0,void 0,(function*(){return this.addRecipients(e,[t])}))}reAddRecipient(e,t){return __awaiter(this,void 0,void 0,(function*(){const r=(yield this.keyknoxManager.v2GetKeys({root:this.root,path:e,identity:this.identity})).map(r=>__awaiter(this,void 0,void 0,(function*(){const i=yield this.keyknoxManager.v2Pull({root:this.root,path:e,key:r,identity:this.identity,privateKey:this.privateKey,publicKeys:this.publicKey});yield this.removeRecipient(e,t.identity,Number(r)),yield this.keyknoxManager.v2Push({root:this.root,path:e,key:r,identities:[t.identity],value:i.value,privateKey:this.privateKey,publicKeys:[this.publicKey,t.publicKey],keyknoxHash:i.keyknoxHash})})));try{yield Promise.all(r)}catch(e){throw CloudGroupTicketStorage.throwIfRecipientIsNotFound(e),e}}))}removeRecipient(e,t,r){return __awaiter(this,void 0,void 0,(function*(){yield this.keyknoxManager.v2Reset({identity:t,root:this.root,path:e,key:"number"==typeof r?r.toString():void 0})}))}delete(e){return __awaiter(this,void 0,void 0,(function*(){return this.keyknoxManager.v2Reset({root:this.root,path:e})}))}static throwIfRecipientIsNotFound(e){if("FoundationError"===e.name&&/recipient defined with id is not found/gi.test(e.message))throw new GroupTicketNoAccessError}}function serialize(e){const t={};return e.forEach((e,r)=>{t[r]={data:e.data,meta:e.meta,creation_date:Number(e.creationDate),name:e.name,modification_date:Number(e.modificationDate)},null===t[r].meta&&delete t[r].meta}),base64.encode(JSON.stringify(t))}function deserialize(e){const t=base64.decode(e);if(!t.length)return new Map;const r=JSON.parse(t);return Object.keys(r).reduce((e,t)=>{const i=r[t];return e.set(t,{name:i.name,data:i.data,creationDate:new Date(i.creation_date),modificationDate:new Date(i.modification_date),meta:void 0===i.meta?null:i.meta}),e},new Map)}CloudGroupTicketStorage.DEFAULT_ROOT="group-sessions";class CloudKeyStorage{constructor(e,t,r){this.cache=new Map,this.syncWasCalled=!1,this.keyknoxManager=e,this.privateKey=t,this.publicKeys=r}static create(e){const{accessTokenProvider:t,privateKey:r,publicKeys:i,virgilCrypto:o}=e,n=KeyknoxManager.create(t,new KeyknoxCrypto(o));return new CloudKeyStorage(n,r,i)}storeEntries(e){return __awaiter(this,void 0,void 0,(function*(){return this.throwUnlessSyncWasCalled(),e.forEach(e=>{this.throwIfCloudEntryExists(e.name),this.cache.set(e.name,CloudKeyStorage.createCloudEntry(e))}),yield this.pushCacheEntries(),e.map(e=>this.cache.get(e.name))}))}storeEntry(e,t,r){return __awaiter(this,void 0,void 0,(function*(){const[i]=yield this.storeEntries([{name:e,data:t,meta:r}]);return i}))}updateEntry(e,t,r){return __awaiter(this,void 0,void 0,(function*(){this.throwUnlessSyncWasCalled(),this.throwUnlessCloudEntryExists(e);const i=CloudKeyStorage.createCloudEntry({name:e,data:t,meta:r},this.cache.get(e).creationDate);return this.cache.set(e,i),yield this.pushCacheEntries(),i}))}retrieveEntry(e){return this.throwUnlessSyncWasCalled(),this.throwUnlessCloudEntryExists(e),this.cache.get(e)}retrieveAllEntries(){return this.throwUnlessSyncWasCalled(),Array.from(this.cache.values())}existsEntry(e){return this.throwUnlessSyncWasCalled(),this.cache.has(e)}deleteEntry(e){return __awaiter(this,void 0,void 0,(function*(){yield this.deleteEntries([e])}))}deleteEntries(e){return __awaiter(this,void 0,void 0,(function*(){this.throwUnlessSyncWasCalled(),e.forEach(e=>{this.throwUnlessCloudEntryExists(e),this.cache.delete(e)}),yield this.pushCacheEntries()}))}deleteAllEntries(){return __awaiter(this,void 0,void 0,(function*(){this.cache.clear(),this.decryptedKeyknoxValue=yield this.keyknoxManager.v1Reset()}))}updateRecipients(e){return __awaiter(this,void 0,void 0,(function*(){this.throwUnlessSyncWasCalled();const{newPrivateKey:t,newPublicKeys:r}=e;this.decryptedKeyknoxValue=yield this.keyknoxManager.v1UpdateRecipients({newPrivateKey:t,newPublicKeys:r,privateKey:this.privateKey,publicKeys:this.publicKeys}),this.privateKey=t||this.privateKey,this.publicKeys=r||this.publicKeys,this.cache=deserialize(this.decryptedKeyknoxValue.value)}))}retrieveCloudEntries(){return __awaiter(this,void 0,void 0,(function*(){this.decryptedKeyknoxValue=yield this.keyknoxManager.v1Pull(this.privateKey,this.publicKeys),this.cache=deserialize(this.decryptedKeyknoxValue.value),this.syncWasCalled=!0}))}throwUnlessSyncWasCalled(){if(!this.syncWasCalled)throw new CloudKeyStorageOutOfSyncError}throwUnlessCloudEntryExists(e){if(!this.cache.has(e))throw new CloudEntryDoesntExistError(e)}throwIfCloudEntryExists(e){if(this.cache.has(e))throw new CloudEntryExistsError(e)}pushCacheEntries(){return __awaiter(this,void 0,void 0,(function*(){const e=serialize(this.cache);this.decryptedKeyknoxValue=yield this.keyknoxManager.v1Push(e,this.privateKey,this.publicKeys,this.decryptedKeyknoxValue.keyknoxHash),this.cache=deserialize(this.decryptedKeyknoxValue.value)}))}static createCloudEntry(e,t){const r=new Date;return{name:e.name,data:e.data,meta:void 0===e.meta?null:e.meta,creationDate:t||r,modificationDate:r}}}class KeyEntryStorageWrapper{constructor(e,t){this.formatKeyEntry=e=>Object.assign(Object.assign({},e),{name:e.name.replace(this.prefix,"")}),this.prefix=`_VIRGIL_IDENTITY=${e}.`,this.prefixRegExp=new RegExp(`^${this.prefix}`),this.keyEntryStorage=t}save(e){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.keyEntryStorage.save(Object.assign(Object.assign({},e),{name:this.getKeyEntryName(e.name)}));return this.formatKeyEntry(t)}))}load(e){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.keyEntryStorage.load(this.getKeyEntryName(e));return null===t?null:this.formatKeyEntry(t)}))}exists(e){return this.keyEntryStorage.exists(this.getKeyEntryName(e))}remove(e){return this.keyEntryStorage.remove(this.getKeyEntryName(e))}list(){return __awaiter(this,void 0,void 0,(function*(){return(yield this.getAllKeyEntries()).map(this.formatKeyEntry)}))}update(e){return __awaiter(this,void 0,void 0,(function*(){const t=yield this.keyEntryStorage.update(Object.assign(Object.assign({},e),{name:this.getKeyEntryName(e.name)}));return this.formatKeyEntry(t)}))}clear(){return __awaiter(this,void 0,void 0,(function*(){const e=yield this.getAllKeyEntries();for(const t of e)yield this.keyEntryStorage.remove(t.name)}))}getKeyEntryName(e){return`${this.prefix}${e}`}getAllKeyEntries(){return __awaiter(this,void 0,void 0,(function*(){return(yield this.keyEntryStorage.list()).filter(e=>this.prefixRegExp.test(e.name))}))}}const creationDateKey="k_cda",modificationDateKey="k_mda";function createKeyEntry(e){return{name:e.name,value:e.data,meta:Object.assign(Object.assign({},e.meta),{[creationDateKey]:e.creationDate.toISOString(),[modificationDateKey]:e.modificationDate.toISOString()})}}function extractDate(e){if(!e.meta)throw new TypeError("Invalid 'IKeyEntry'");return{creationDate:new Date(e.meta[creationDateKey]),modificationDate:new Date(e.meta[modificationDateKey])}}class SyncKeyStorage{constructor(e,t,r){this.cloudKeyStorage=t,this.keyEntryStorageWrapper=new KeyEntryStorageWrapper(e,r)}static create(e){const{virgilCrypto:t,identity:r,accessTokenProvider:i,privateKey:o,publicKeys:n}=e,s=CloudKeyStorage.create({accessTokenProvider:i,privateKey:o,publicKeys:n,virgilCrypto:t});return new SyncKeyStorage(r,s,e.keyEntryStorage)}storeEntries(e){return __awaiter(this,void 0,void 0,(function*(){const t=e.map(e=>this.throwIfKeyEntryExists(e.name));yield Promise.all(t);const r=(yield this.cloudKeyStorage.storeEntries(e)).map(e=>__awaiter(this,void 0,void 0,(function*(){const t=createKeyEntry(e);return this.keyEntryStorageWrapper.save(t)})));return Promise.all(r)}))}storeEntry(e,t,r){return __awaiter(this,void 0,void 0,(function*(){const[i]=yield this.storeEntries([{name:e,data:t,meta:r}]);return i}))}updateEntry(e,t,r){return __awaiter(this,void 0,void 0,(function*(){yield this.throwUnlessKeyEntryExists(e);const i=createKeyEntry(yield this.cloudKeyStorage.updateEntry(e,t,r));yield this.keyEntryStorageWrapper.update(i)}))}retrieveEntry(e){return __awaiter(this,void 0,void 0,(function*(){return yield this.throwUnlessKeyEntryExists(e),this.keyEntryStorageWrapper.load(e)}))}retrieveAllEntries(){return this.keyEntryStorageWrapper.list()}existsEntry(e){return this.keyEntryStorageWrapper.exists(e)}deleteEntry(e){return this.deleteEntries([e])}deleteEntries(e){return __awaiter(this,void 0,void 0,(function*(){yield this.cloudKeyStorage.deleteEntries(e);const t=e.map(e=>this.keyEntryStorageWrapper.remove(e));yield Promise.all(t)}))}deleteAllEntries(){return __awaiter(this,void 0,void 0,(function*(){yield this.cloudKeyStorage.deleteAllEntries(),yield this.keyEntryStorageWrapper.clear()}))}updateRecipients(e){return __awaiter(this,void 0,void 0,(function*(){const{newPrivateKey:t,newPublicKeys:r}=e;return this.cloudKeyStorage.updateRecipients({newPrivateKey:t,newPublicKeys:r})}))}sync(){return __awaiter(this,void 0,void 0,(function*(){yield this.cloudKeyStorage.retrieveCloudEntries();const e=this.cloudKeyStorage.retrieveAllEntries(),t=e.reduce((e,t)=>(e[t.name]=t,e),{}),r=yield this.keyEntryStorageWrapper.list(),i=r.reduce((e,t)=>(e[t.name]=t,e),{}),o=[],n=[],s=[];return e.forEach(e=>{const t=i[e.name];if(t){const{modificationDate:r}=extractDate(t);if(e.modificationDate>r)return n.push(e.name)}else o.push(e.name)}),r.forEach(e=>{t[e.name]||s.push(e.name)}),this.syncKeyStorage(o,n,s)}))}throwUnlessKeyEntryExists(e){return __awaiter(this,void 0,void 0,(function*(){if(!(yield this.keyEntryStorageWrapper.exists(e)))throw new KeyEntryDoesntExistError(e)}))}throwIfKeyEntryExists(e){return __awaiter(this,void 0,void 0,(function*(){if(yield this.keyEntryStorageWrapper.exists(e))throw new KeyEntryExistsError(e)}))}syncKeyStorage(e,t,r){return __awaiter(this,void 0,void 0,(function*(){const i=r.map(e=>__awaiter(this,void 0,void 0,(function*(){yield this.keyEntryStorageWrapper.remove(e)}))),o=t.map(e=>__awaiter(this,void 0,void 0,(function*(){const t=createKeyEntry(this.cloudKeyStorage.retrieveEntry(e));yield this.keyEntryStorageWrapper.update(t)}))),n=e.map(e=>__awaiter(this,void 0,void 0,(function*(){const t=createKeyEntry(this.cloudKeyStorage.retrieveEntry(e));yield this.keyEntryStorageWrapper.save(t)})));yield Promise.all([...i,...o,...n])}))}}exports.CloudEntryDoesntExistError=CloudEntryDoesntExistError,exports.CloudEntryExistsError=CloudEntryExistsError,exports.CloudGroupTicketStorage=CloudGroupTicketStorage,exports.CloudKeyStorage=CloudKeyStorage,exports.CloudKeyStorageOutOfSyncError=CloudKeyStorageOutOfSyncError,exports.GroupTicketAlreadyExistsError=GroupTicketAlreadyExistsError,exports.GroupTicketDoesntExistError=GroupTicketDoesntExistError,exports.GroupTicketNoAccessError=GroupTicketNoAccessError,exports.KeyEntryDoesntExistError=KeyEntryDoesntExistError,exports.KeyEntryExistsError=KeyEntryExistsError,exports.KeyknoxClient=KeyknoxClient,exports.KeyknoxClientError=KeyknoxClientError,exports.KeyknoxCrypto=KeyknoxCrypto,exports.KeyknoxError=KeyknoxError,exports.KeyknoxManager=KeyknoxManager,exports.SyncKeyStorage=SyncKeyStorage;
