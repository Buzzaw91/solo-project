'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var sdkCrypto = require('@virgilsecurity/sdk-crypto');
var initFoundationModules = _interopDefault(require('@virgilsecurity/core-foundation/browser.asmjs.cjs.js'));
var initUtils = require('@virgilsecurity/init-utils');
var dataUtils = require('@virgilsecurity/data-utils');

const moduleInitializer = new initUtils.ModuleInitializer();
moduleInitializer.addModule('foundation', initFoundationModules);
const hasFoundationModules = () => moduleInitializer.hasModule('foundation');
const getFoundationModules = () => moduleInitializer.getModule('foundation');
const setFoundationModules = (foundationModules) => {
    moduleInitializer.setModule('foundation', foundationModules);
};
const initCrypto = moduleInitializer.loadModules;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const addHashAlgorithm = (obj, algIdName) => {
    Object.defineProperty(obj, algIdName, {
        configurable: false,
        enumerable: true,
        get: () => {
            const { AlgId } = getFoundationModules();
            return AlgId[algIdName];
        },
    });
};
// eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
const HashAlgorithm = {};
addHashAlgorithm(HashAlgorithm, 'SHA224');
addHashAlgorithm(HashAlgorithm, 'SHA256');
addHashAlgorithm(HashAlgorithm, 'SHA384');
addHashAlgorithm(HashAlgorithm, 'SHA512');

const addKeyPairType = (obj, name, algIdName, bitlen) => {
    Object.defineProperty(obj, name, {
        configurable: false,
        enumerable: true,
        get: () => {
            const { AlgId } = moduleInitializer.getModule('foundation');
            return {
                bitlen,
                algId: AlgId[algIdName],
            };
        },
    });
};
// eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
const KeyPairType = {};
addKeyPairType(KeyPairType, 'Default', 'ED25519');
addKeyPairType(KeyPairType, 'ED25519', 'ED25519');
addKeyPairType(KeyPairType, 'CURVE25519', 'CURVE25519');
addKeyPairType(KeyPairType, 'SECP256R1', 'SECP256R1');
addKeyPairType(KeyPairType, 'RSA_2048', 'RSA', 2048);
addKeyPairType(KeyPairType, 'RSA_3072', 'RSA', 3072);
addKeyPairType(KeyPairType, 'RSA_4096', 'RSA', 4096);
addKeyPairType(KeyPairType, 'RSA_8192', 'RSA', 8192);

function validatePrivateKey(privateKey, label = 'privateKey') {
    if (privateKey == null ||
        !(privateKey.identifier instanceof Uint8Array) ||
        !(typeof privateKey.lowLevelPrivateKey === 'object') ||
        !(typeof privateKey.isDisposed === 'boolean')) {
        throw new TypeError(`\`${label}\` is not a VirgilPrivateKey.`);
    }
    if (privateKey.isDisposed) {
        throw new Error(`Cannot use \`${label}\` after it was disposed.`);
    }
}
function validatePublicKey(publicKey, label = 'publicKey') {
    if (publicKey == null ||
        !(publicKey.identifier instanceof Uint8Array) ||
        !(typeof publicKey.lowLevelPublicKey === 'object') ||
        !(typeof publicKey.isDisposed === 'boolean')) {
        throw new TypeError(`\`${label}\` is not a VirgilPublicKey.`);
    }
    if (publicKey.isDisposed) {
        throw new Error(`Cannot use \`${label}\` after is was disposed.`);
    }
}
function validatePublicKeysArray(publicKeys, label = 'publicKeys') {
    if (publicKeys.length === 0) {
        throw new TypeError(`\`${label}\` array must not be empty.`);
    }
    publicKeys.forEach(publicKey => validatePublicKey(publicKey));
}

const getRandom = (() => {
    let random;
    return () => {
        if (!random) {
            const foundation = getFoundationModules();
            random = new foundation.CtrDrbg();
            try {
                random.setupDefaults();
            }
            catch (error) {
                random.delete();
                random = undefined;
                throw error;
            }
        }
        return random;
    };
})();
function parseGroupSessionMessage(messageData) {
    const message = getFoundationModules().GroupSessionMessage.deserialize(messageData);
    const info = {
        epochNumber: message.getEpoch(),
        sessionId: dataUtils.toBuffer(message.getSessionId()).toString('hex'),
        data: dataUtils.toBuffer(messageData).toString('base64'),
    };
    message.delete();
    return info;
}
function getEpochNumberFromEpochMessage(epochMessageData) {
    const epoch = getFoundationModules().GroupSessionMessage.deserialize(epochMessageData);
    const epochNumber = epoch.getEpoch();
    epoch.delete();
    return epochNumber;
}
function createLowLevelSession(epochMessages) {
    const module = getFoundationModules();
    const session = new module.GroupSession();
    session.rng = getRandom();
    const deleteQueue = [];
    try {
        for (const epochMessageData of epochMessages) {
            const epoch = getFoundationModules().GroupSessionMessage.deserialize(epochMessageData);
            deleteQueue.push(epoch);
            session.addEpoch(epoch);
        }
        return session;
    }
    finally {
        while (deleteQueue.length) {
            const obj = deleteQueue.pop();
            obj && obj.delete();
        }
    }
}
function computeSessionId(groupId) {
    const foundation = getFoundationModules();
    const sha512 = new foundation.Sha512();
    try {
        return sha512.hash(groupId).subarray(0, 32);
    }
    finally {
        sha512.delete();
    }
}
function createInitialEpoch(sessionId) {
    const foundation = getFoundationModules();
    const ticket = new foundation.GroupSessionTicket();
    ticket.rng = getRandom();
    try {
        ticket.setupTicketAsNew(sessionId);
        return ticket.getTicketMessage();
    }
    finally {
        ticket.delete();
    }
}

function createVirgilGroupSession(epochMessages) {
    epochMessages = epochMessages
        .slice()
        .sort((a, b) => getEpochNumberFromEpochMessage(a) - getEpochNumberFromEpochMessage(b));
    return {
        getSessionId() {
            const session = createLowLevelSession(epochMessages);
            const id = session.getSessionId();
            session.delete();
            return dataUtils.toBuffer(id).toString('hex');
        },
        getCurrentEpochNumber() {
            return getEpochNumberFromEpochMessage(epochMessages[epochMessages.length - 1]);
        },
        encrypt(data, signingPrivateKey) {
            const dataBytes = dataUtils.dataToUint8Array(data, 'utf8');
            validatePrivateKey(signingPrivateKey);
            let session;
            try {
                session = createLowLevelSession(epochMessages);
                const message = session.encrypt(dataBytes, signingPrivateKey.lowLevelPrivateKey);
                const encrypted = message.serialize();
                message.delete();
                return dataUtils.toBuffer(encrypted);
            }
            finally {
                session && session.delete();
            }
        },
        decrypt(encryptedData, verifyingPublicKey) {
            const encryptedDataBytes = dataUtils.dataToUint8Array(encryptedData, 'base64');
            validatePublicKey(verifyingPublicKey);
            let session;
            let message;
            try {
                session = createLowLevelSession(epochMessages);
                message = getFoundationModules().GroupSessionMessage.deserialize(encryptedDataBytes);
                return dataUtils.toBuffer(session.decrypt(message, verifyingPublicKey.lowLevelPublicKey));
            }
            finally {
                message && message.delete();
                session && session.delete();
            }
        },
        addNewEpoch() {
            const session = createLowLevelSession(epochMessages);
            try {
                const newEpochTicket = session.createGroupTicket();
                const newEpoch = newEpochTicket.getTicketMessage();
                const newEpochMessage = newEpoch.serialize();
                epochMessages.push(newEpochMessage);
                newEpoch.delete();
                newEpochTicket.delete();
                return parseGroupSessionMessage(newEpochMessage);
            }
            finally {
                session.delete();
            }
        },
        export() {
            return epochMessages.map(dataUtils.toBuffer);
        },
        parseMessage(messageData) {
            const messageBytes = dataUtils.dataToUint8Array(messageData, 'base64');
            return parseGroupSessionMessage(messageBytes);
        },
    };
}

const DATA_SIGNATURE_KEY = dataUtils.NodeBuffer.from('VIRGIL-DATA-SIGNATURE', 'utf8');
const DATA_SIGNER_ID_KEY = dataUtils.NodeBuffer.from('VIRGIL-DATA-SIGNER-ID', 'utf8');

const toArray = (val) => {
    return val == null ? [] : Array.isArray(val) ? val : [val];
};

class VirgilPrivateKey {
    constructor(indentifier, lowLevelPrivateKey) {
        this.identifier = indentifier;
        this.lowLevelPrivateKey = lowLevelPrivateKey;
        this._isDisposed = false;
    }
    get isDisposed() {
        return this._isDisposed;
    }
    dispose() {
        this.lowLevelPrivateKey.delete();
        this._isDisposed = true;
    }
}

class VirgilPublicKey {
    constructor(identifier, lowLevelPublicKey) {
        this.identifier = identifier;
        this.lowLevelPublicKey = lowLevelPublicKey;
        this._isDisposed = false;
    }
    get isDisposed() {
        return this._isDisposed;
    }
    get key() {
        const foundationModules = getFoundationModules();
        const keyAsn1Serializer = new foundationModules.KeyAsn1Serializer();
        try {
            keyAsn1Serializer.setupDefaults();
            return keyAsn1Serializer.serializePublicKey(this.lowLevelPublicKey);
        }
        finally {
            keyAsn1Serializer.delete();
        }
    }
    dispose() {
        this.lowLevelPublicKey.delete();
        this._isDisposed = true;
    }
}

class VirgilStreamCipher {
    constructor(publicKey, signature) {
        this._isFinished = false;
        this.isRunning = false;
        this.isDisposed = false;
        const foundationModules = getFoundationModules();
        this.publicKeys = toArray(publicKey);
        validatePublicKeysArray(this.publicKeys);
        this.ctrDrbg = new foundationModules.CtrDrbg();
        try {
            this.ctrDrbg.setupDefaults();
        }
        catch (error) {
            this.ctrDrbg.delete();
            throw error;
        }
        this.recipientCipher = new foundationModules.RecipientCipher();
        this.aes256Gcm = new foundationModules.Aes256Gcm();
        this.recipientCipher.encryptionCipher = this.aes256Gcm;
        this.recipientCipher.random = this.ctrDrbg;
        this.publicKeys.forEach(({ identifier }, index) => {
            this.recipientCipher.addKeyRecipient(identifier, this.publicKeys[index].lowLevelPublicKey);
        });
        if (signature) {
            const mySignature = dataUtils.dataToUint8Array(signature, 'base64');
            this.messageInfoCustomParams = this.recipientCipher.customParams();
            this.messageInfoCustomParams.addData(DATA_SIGNATURE_KEY, mySignature);
        }
    }
    get isFinished() {
        return this._isFinished;
    }
    start() {
        this.ensureLegalState();
        this.recipientCipher.startEncryption();
        this.isRunning = true;
        return dataUtils.toBuffer(this.recipientCipher.packMessageInfo());
    }
    update(data) {
        this.ensureLegalState();
        this.ensureIsRunning();
        const myData = dataUtils.dataToUint8Array(data, 'utf8');
        return dataUtils.toBuffer(this.recipientCipher.processEncryption(myData));
    }
    final(dispose = true) {
        this.ensureLegalState();
        this.ensureIsRunning();
        try {
            return dataUtils.toBuffer(this.recipientCipher.finishEncryption());
        }
        finally {
            this._isFinished = true;
            this.isRunning = false;
            if (dispose) {
                this.dispose();
            }
        }
    }
    dispose() {
        this.recipientCipher.delete();
        this.aes256Gcm.delete();
        this.ctrDrbg.delete();
        if (this.messageInfoCustomParams) {
            this.messageInfoCustomParams.delete();
        }
        this.isDisposed = true;
    }
    ensureLegalState() {
        if (this._isFinished) {
            throw new Error('Illegal state. Cannot use cipher after the `final` method has been called.');
        }
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot use cipher after the `dispose` method has been called.');
        }
    }
    ensureIsRunning() {
        if (!this.isRunning) {
            throw new Error('Illegal state. Cannot use cipher before the `start` method.');
        }
    }
}

class VirgilStreamDecipher {
    constructor(privateKey) {
        this._isFinished = false;
        this.isDisposed = false;
        const foundationModules = getFoundationModules();
        validatePrivateKey(privateKey);
        this.privateKey = privateKey;
        this.recipientCipher = new foundationModules.RecipientCipher();
        try {
            this.recipientCipher.startDecryptionWithKey(privateKey.identifier, this.privateKey.lowLevelPrivateKey, new Uint8Array(0));
        }
        catch (error) {
            this.recipientCipher.delete();
            throw error;
        }
    }
    get isFinished() {
        return this._isFinished;
    }
    getSignature() {
        if (!this._isFinished) {
            throw new Error('Illegal state. Cannot get signature before the `final` method has been called.');
        }
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot get signature after the `dispose` method has been called.');
        }
        const messageInfoCustomParams = this.recipientCipher.customParams();
        try {
            return dataUtils.toBuffer(messageInfoCustomParams.findData(DATA_SIGNATURE_KEY));
        }
        finally {
            messageInfoCustomParams.delete();
        }
    }
    update(data) {
        this.ensureLegalState();
        const myData = dataUtils.dataToUint8Array(data, 'utf8');
        return dataUtils.toBuffer(this.recipientCipher.processDecryption(myData));
    }
    final(dispose = true) {
        this.ensureLegalState();
        try {
            return dataUtils.toBuffer(this.recipientCipher.finishDecryption());
        }
        finally {
            this._isFinished = true;
            if (dispose) {
                this.dispose();
            }
        }
    }
    dispose() {
        this.recipientCipher.delete();
        this.isDisposed = true;
    }
    ensureLegalState() {
        if (this._isFinished) {
            throw new Error('Illegal state. Cannot use cipher after the `final` method has been called.');
        }
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot use cipher after the `dispose` method has been called.');
        }
    }
}

class VirgilStreamSigner {
    constructor() {
        this.isDisposed = false;
        const foundationModules = getFoundationModules();
        this.signer = new foundationModules.Signer();
        this.sha512 = new foundationModules.Sha512();
        this.signer.hash = this.sha512;
        this.signer.reset();
    }
    update(data) {
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot use signer after the `dispose` method has been called.');
        }
        const myData = dataUtils.dataToUint8Array(data, 'utf8');
        this.signer.appendData(myData);
        return this;
    }
    sign(privateKey, final = true) {
        if (this.isDisposed) {
            throw new Error('Illegal state. The VirgilStreamSigner has been disposed. ' +
                'Pass `false` as the second argument to the `sign` method ' +
                'if you need to generate more than one signature.');
        }
        validatePrivateKey(privateKey);
        const result = this.signer.sign(privateKey.lowLevelPrivateKey);
        if (final) {
            this.dispose();
        }
        return dataUtils.toBuffer(result);
    }
    dispose() {
        this.signer.delete();
        this.sha512.delete();
    }
}

class VirgilStreamVerifier {
    constructor(signature) {
        this.isDisposed = false;
        const foundationModules = getFoundationModules();
        const mySignature = dataUtils.dataToUint8Array(signature, 'base64');
        this.verifier = new foundationModules.Verifier();
        try {
            this.verifier.reset(mySignature);
        }
        catch (error) {
            this.verifier.delete();
            throw error;
        }
    }
    update(data) {
        if (this.isDisposed) {
            throw new Error('Illegal state. Cannot use signer after the `dispose` method has been called.');
        }
        const myData = dataUtils.dataToUint8Array(data, 'utf8');
        this.verifier.appendData(myData);
        return this;
    }
    verify(publicKey, final = true) {
        if (this.isDisposed) {
            throw new Error('Illegal state. The VirgilStreamVerifier has been disposed. ' +
                'Pass `false` as the second argument to the `verify` method ' +
                'if you need to verify with more than one public key.');
        }
        validatePublicKey(publicKey);
        const result = this.verifier.verify(publicKey.lowLevelPublicKey);
        if (final) {
            this.dispose();
        }
        return result;
    }
    dispose() {
        this.verifier.delete();
        this.isDisposed = true;
    }
}

const MIN_GROUP_ID_BYTE_LENGTH = 10;
class VirgilCrypto {
    constructor(options = {}) {
        this.hashAlgorithm = HashAlgorithm;
        this.keyPairType = KeyPairType;
        const foundation = getFoundationModules();
        this.keyProvider = new foundation.KeyProvider();
        try {
            this.keyProvider.setupDefaults();
        }
        catch (error) {
            this.keyProvider.delete();
            throw error;
        }
        this.random = new foundation.CtrDrbg();
        try {
            this.random.setupDefaults();
        }
        catch (error) {
            this.random.delete();
            this.keyProvider.delete();
            throw error;
        }
        this.defaultKeyPairType = options.defaultKeyPairType || KeyPairType.Default;
        this.useSha256Identifiers = options.useSha256Identifiers || false;
        this._isDisposed = false;
    }
    get isDisposed() {
        return this._isDisposed;
    }
    dispose() {
        this.keyProvider.delete();
        this.random.delete();
        this._isDisposed = true;
    }
    generateKeys(type) {
        this.throwIfDisposed();
        const keyPairType = type ? type : this.defaultKeyPairType;
        const foundation = getFoundationModules();
        const keyProvider = new foundation.KeyProvider();
        try {
            keyProvider.setupDefaults();
        }
        catch (error) {
            keyProvider.delete();
            throw error;
        }
        if (keyPairType.algId === foundation.AlgId.RSA) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            keyProvider.setRsaParams(keyPairType.bitlen);
        }
        let lowLevelPrivateKey;
        try {
            lowLevelPrivateKey = keyProvider.generatePrivateKey(keyPairType.algId);
        }
        catch (error) {
            keyProvider.delete();
            throw error;
        }
        const lowLevelPublicKey = lowLevelPrivateKey.extractPublicKey();
        try {
            const serializedPublicKey = this.keyProvider.exportPublicKey(lowLevelPublicKey);
            const identifier = this.calculateKeypairIdentifier(serializedPublicKey, this.useSha256Identifiers);
            return {
                privateKey: new VirgilPrivateKey(identifier, lowLevelPrivateKey),
                publicKey: new VirgilPublicKey(identifier, lowLevelPublicKey),
            };
        }
        finally {
            keyProvider.delete();
        }
    }
    generateKeysFromKeyMaterial(keyMaterial, type) {
        this.throwIfDisposed();
        const keyPairType = type ? type : this.defaultKeyPairType;
        const myKeyMaterial = dataUtils.dataToUint8Array(keyMaterial, 'base64');
        const foundation = getFoundationModules();
        const keyMaterialRng = new foundation.KeyMaterialRng();
        keyMaterialRng.resetKeyMaterial(myKeyMaterial);
        const keyProvider = new foundation.KeyProvider();
        try {
            keyProvider.setupDefaults();
        }
        catch (error) {
            keyMaterialRng.delete();
            keyProvider.delete();
            throw error;
        }
        keyProvider.random = keyMaterialRng;
        if (keyPairType.algId === foundation.AlgId.RSA) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            keyProvider.setRsaParams(keyPairType.bitlen);
        }
        let lowLevelPrivateKey;
        try {
            lowLevelPrivateKey = keyProvider.generatePrivateKey(keyPairType.algId);
        }
        catch (error) {
            keyMaterialRng.delete();
            keyProvider.delete();
            throw error;
        }
        const lowLevelPublicKey = lowLevelPrivateKey.extractPublicKey();
        try {
            const serializedPublicKey = this.keyProvider.exportPublicKey(lowLevelPublicKey);
            const identifier = this.calculateKeypairIdentifier(serializedPublicKey, this.useSha256Identifiers);
            return {
                privateKey: new VirgilPrivateKey(identifier, lowLevelPrivateKey),
                publicKey: new VirgilPublicKey(identifier, lowLevelPublicKey),
            };
        }
        finally {
            keyMaterialRng.delete();
            keyProvider.delete();
        }
    }
    importPrivateKey(rawPrivateKey) {
        this.throwIfDisposed();
        const serializedPrivateKey = dataUtils.dataToUint8Array(rawPrivateKey, 'base64');
        const lowLevelPrivateKey = this.keyProvider.importPrivateKey(serializedPrivateKey);
        const lowLevelPublicKey = lowLevelPrivateKey.extractPublicKey();
        try {
            const serializedPublicKey = this.keyProvider.exportPublicKey(lowLevelPublicKey);
            const identifier = this.calculateKeypairIdentifier(serializedPublicKey, this.useSha256Identifiers);
            return new VirgilPrivateKey(identifier, lowLevelPrivateKey);
        }
        finally {
            lowLevelPublicKey.delete();
        }
    }
    exportPrivateKey(privateKey) {
        this.throwIfDisposed();
        validatePrivateKey(privateKey);
        return dataUtils.toBuffer(this.keyProvider.exportPrivateKey(privateKey.lowLevelPrivateKey));
    }
    importPublicKey(rawPublicKey) {
        this.throwIfDisposed();
        const serializedPublicKey = dataUtils.dataToUint8Array(rawPublicKey, 'base64');
        const lowLevelPublicKey = this.keyProvider.importPublicKey(serializedPublicKey);
        const identifier = this.calculateKeypairIdentifier(serializedPublicKey, this.useSha256Identifiers);
        return new VirgilPublicKey(identifier, lowLevelPublicKey);
    }
    exportPublicKey(publicKey) {
        this.throwIfDisposed();
        return dataUtils.toBuffer(this.keyProvider.exportPublicKey(publicKey.lowLevelPublicKey));
    }
    encrypt(data, publicKey) {
        this.throwIfDisposed();
        const myData = dataUtils.dataToUint8Array(data, 'utf8');
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        const foundation = getFoundationModules();
        const recipientCipher = new foundation.RecipientCipher();
        const aes256Gcm = new foundation.Aes256Gcm();
        recipientCipher.encryptionCipher = aes256Gcm;
        recipientCipher.random = this.random;
        publicKeys.forEach(({ identifier }, index) => {
            recipientCipher.addKeyRecipient(identifier, publicKeys[index].lowLevelPublicKey);
        });
        try {
            recipientCipher.startEncryption();
            const messageInfo = recipientCipher.packMessageInfo();
            const processEncryption = recipientCipher.processEncryption(myData);
            const finishEncryption = recipientCipher.finishEncryption();
            return dataUtils.NodeBuffer.concat([messageInfo, processEncryption, finishEncryption]);
        }
        finally {
            recipientCipher.delete();
            aes256Gcm.delete();
        }
    }
    decrypt(encryptedData, privateKey) {
        this.throwIfDisposed();
        const myData = dataUtils.dataToUint8Array(encryptedData, 'base64');
        validatePrivateKey(privateKey);
        const foundation = getFoundationModules();
        const recipientCipher = new foundation.RecipientCipher();
        recipientCipher.random = this.random;
        try {
            recipientCipher.startDecryptionWithKey(privateKey.identifier, privateKey.lowLevelPrivateKey, new Uint8Array(0));
            const processDecryption = recipientCipher.processDecryption(myData);
            const finishDecryption = recipientCipher.finishDecryption();
            return dataUtils.NodeBuffer.concat([processDecryption, finishDecryption]);
        }
        finally {
            recipientCipher.delete();
        }
    }
    calculateHash(data, algorithm = HashAlgorithm.SHA512) {
        const myData = dataUtils.dataToUint8Array(data, 'utf8');
        let result;
        switch (algorithm) {
            case HashAlgorithm.SHA224:
                result = this.createHash(myData, getFoundationModules().Sha224);
                break;
            case HashAlgorithm.SHA256:
                result = this.createHash(myData, getFoundationModules().Sha256);
                break;
            case HashAlgorithm.SHA384:
                result = this.createHash(myData, getFoundationModules().Sha384);
                break;
            case HashAlgorithm.SHA512:
                result = this.createHash(myData, getFoundationModules().Sha512);
                break;
            default:
                throw new TypeError('Unknown hash algorithm');
        }
        return dataUtils.toBuffer(result);
    }
    extractPublicKey(privateKey) {
        this.throwIfDisposed();
        validatePrivateKey(privateKey);
        const lowLevelPublicKey = privateKey.lowLevelPrivateKey.extractPublicKey();
        return new VirgilPublicKey(privateKey.identifier, lowLevelPublicKey);
    }
    calculateSignature(data, privateKey) {
        this.throwIfDisposed();
        const myData = dataUtils.dataToUint8Array(data, 'utf8');
        validatePrivateKey(privateKey);
        const foundation = getFoundationModules();
        const signer = new foundation.Signer();
        const sha512 = new foundation.Sha512();
        signer.hash = sha512;
        signer.reset();
        signer.appendData(myData);
        try {
            const signature = signer.sign(privateKey.lowLevelPrivateKey);
            return dataUtils.toBuffer(signature);
        }
        finally {
            signer.delete();
            sha512.delete();
        }
    }
    verifySignature(data, signature, publicKey) {
        this.throwIfDisposed();
        const myData = dataUtils.dataToUint8Array(data, 'utf8');
        const mySignature = dataUtils.dataToUint8Array(signature, 'base64');
        validatePublicKey(publicKey);
        const foundation = getFoundationModules();
        const verifier = new foundation.Verifier();
        try {
            verifier.reset(mySignature);
        }
        catch (error) {
            verifier.delete();
            throw error;
        }
        verifier.appendData(myData);
        const result = verifier.verify(publicKey.lowLevelPublicKey);
        verifier.delete();
        return result;
    }
    signThenEncrypt(data, privateKey, publicKey) {
        this.throwIfDisposed();
        const myData = dataUtils.dataToUint8Array(data, 'utf8');
        validatePrivateKey(privateKey);
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        const foundation = getFoundationModules();
        const recipientCipher = new foundation.RecipientCipher();
        const aes256Gcm = new foundation.Aes256Gcm();
        recipientCipher.encryptionCipher = aes256Gcm;
        recipientCipher.random = this.random;
        publicKeys.forEach(({ identifier }, index) => {
            recipientCipher.addKeyRecipient(identifier, publicKeys[index].lowLevelPublicKey);
        });
        const messageInfoCustomParams = recipientCipher.customParams();
        try {
            const signature = this.calculateSignature(myData, privateKey);
            messageInfoCustomParams.addData(DATA_SIGNATURE_KEY, signature);
            messageInfoCustomParams.addData(DATA_SIGNER_ID_KEY, privateKey.identifier);
            recipientCipher.startEncryption();
            const messageInfo = recipientCipher.packMessageInfo();
            const processEncryption = recipientCipher.processEncryption(myData);
            const finishEncryption = recipientCipher.finishEncryption();
            return dataUtils.NodeBuffer.concat([messageInfo, processEncryption, finishEncryption]);
        }
        finally {
            recipientCipher.delete();
            aes256Gcm.delete();
            messageInfoCustomParams.delete();
        }
    }
    decryptThenVerify(encryptedData, privateKey, publicKey) {
        this.throwIfDisposed();
        const myEncryptedData = dataUtils.dataToUint8Array(encryptedData, 'base64');
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        validatePrivateKey(privateKey);
        const foundation = getFoundationModules();
        const recipientCipher = new foundation.RecipientCipher();
        recipientCipher.random = this.random;
        let decryptedData;
        try {
            recipientCipher.startDecryptionWithKey(privateKey.identifier, privateKey.lowLevelPrivateKey, new Uint8Array(0));
            const processDecryption = recipientCipher.processDecryption(myEncryptedData);
            const finishDecryption = recipientCipher.finishDecryption();
            decryptedData = dataUtils.NodeBuffer.concat([processDecryption, finishDecryption]);
        }
        catch (error) {
            recipientCipher.delete();
            throw error;
        }
        const messageInfoCustomParams = recipientCipher.customParams();
        let signerPublicKey;
        if (publicKeys.length === 1) {
            signerPublicKey = publicKeys[0];
        }
        else {
            let signerId;
            try {
                signerId = messageInfoCustomParams.findData(DATA_SIGNER_ID_KEY);
            }
            catch (error) {
                recipientCipher.delete();
                messageInfoCustomParams.delete();
                throw error;
            }
            for (let i = 0; i < publicKeys.length; i += 1) {
                if (dataUtils.NodeBuffer.compare(signerId, publicKeys[i].identifier) === 0) {
                    signerPublicKey = publicKeys[i];
                    break;
                }
            }
            if (!signerPublicKey) {
                recipientCipher.delete();
                messageInfoCustomParams.delete();
                throw new Error('Signer not found');
            }
        }
        try {
            const signature = messageInfoCustomParams.findData(DATA_SIGNATURE_KEY);
            const isValid = this.verifySignature(decryptedData, signature, signerPublicKey);
            if (!isValid) {
                throw new Error('Invalid signature');
            }
            return decryptedData;
        }
        finally {
            recipientCipher.delete();
            messageInfoCustomParams.delete();
        }
    }
    getRandomBytes(length) {
        this.throwIfDisposed();
        const bytes = this.random.random(length);
        return dataUtils.toBuffer(bytes);
    }
    signThenEncryptDetached(data, privateKey, publicKey) {
        this.throwIfDisposed();
        const myData = dataUtils.dataToUint8Array(data, 'utf8');
        validatePrivateKey(privateKey);
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        const foundation = getFoundationModules();
        const recipientCipher = new foundation.RecipientCipher();
        const aes256Gcm = new foundation.Aes256Gcm();
        recipientCipher.encryptionCipher = aes256Gcm;
        recipientCipher.random = this.random;
        publicKeys.forEach(({ identifier }, index) => {
            recipientCipher.addKeyRecipient(identifier, publicKeys[index].lowLevelPublicKey);
        });
        const messageInfoCustomParams = recipientCipher.customParams();
        try {
            const signature = this.calculateSignature(myData, privateKey);
            messageInfoCustomParams.addData(DATA_SIGNATURE_KEY, signature);
            messageInfoCustomParams.addData(DATA_SIGNER_ID_KEY, privateKey.identifier);
            recipientCipher.startEncryption();
            const messageInfo = recipientCipher.packMessageInfo();
            const processEncryption = recipientCipher.processEncryption(myData);
            const finishEncryption = recipientCipher.finishEncryption();
            const encryptedData = dataUtils.NodeBuffer.concat([processEncryption, finishEncryption]);
            const metadata = dataUtils.toBuffer(messageInfo);
            return { encryptedData, metadata };
        }
        finally {
            recipientCipher.delete();
            aes256Gcm.delete();
            messageInfoCustomParams.delete();
        }
    }
    decryptThenVerifyDetached(encryptedData, metadata, privateKey, publicKey) {
        this.throwIfDisposed();
        const myEncryptedData = dataUtils.dataToUint8Array(encryptedData, 'base64');
        const myMetadata = dataUtils.dataToUint8Array(metadata, 'base64');
        validatePrivateKey(privateKey);
        const publicKeys = toArray(publicKey);
        validatePublicKeysArray(publicKeys);
        const foundation = getFoundationModules();
        const recipientCipher = new foundation.RecipientCipher();
        recipientCipher.random = this.random;
        let decryptedData;
        try {
            recipientCipher.startDecryptionWithKey(privateKey.identifier, privateKey.lowLevelPrivateKey, myMetadata);
            const processDecryption = recipientCipher.processDecryption(myEncryptedData);
            const finishDecryption = recipientCipher.finishDecryption();
            decryptedData = dataUtils.NodeBuffer.concat([processDecryption, finishDecryption]);
        }
        catch (error) {
            recipientCipher.delete();
            throw error;
        }
        const messageInfoCustomParams = recipientCipher.customParams();
        let signerPublicKey;
        if (publicKeys.length === 1) {
            signerPublicKey = publicKeys[0];
        }
        else {
            let signerId;
            try {
                signerId = messageInfoCustomParams.findData(DATA_SIGNER_ID_KEY);
            }
            catch (error) {
                recipientCipher.delete();
                messageInfoCustomParams.delete();
                throw error;
            }
            for (let i = 0; i < publicKeys.length; i += 1) {
                if (dataUtils.NodeBuffer.compare(signerId, publicKeys[i].identifier) === 0) {
                    signerPublicKey = publicKeys[i];
                    break;
                }
            }
            if (!signerPublicKey) {
                recipientCipher.delete();
                messageInfoCustomParams.delete();
                throw new Error('Signer not found');
            }
        }
        try {
            const signature = messageInfoCustomParams.findData(DATA_SIGNATURE_KEY);
            const isValid = this.verifySignature(decryptedData, signature, signerPublicKey);
            if (!isValid) {
                throw new Error('Invalid signature');
            }
            return decryptedData;
        }
        finally {
            recipientCipher.delete();
            messageInfoCustomParams.delete();
        }
    }
    createStreamCipher(publicKey, signature) {
        this.throwIfDisposed();
        return new VirgilStreamCipher(publicKey, signature);
    }
    createStreamDecipher(privateKey) {
        this.throwIfDisposed();
        return new VirgilStreamDecipher(privateKey);
    }
    createStreamSigner() {
        this.throwIfDisposed();
        return new VirgilStreamSigner();
    }
    createStreamVerifier(signature) {
        this.throwIfDisposed();
        return new VirgilStreamVerifier(signature);
    }
    generateGroupSession(groupId) {
        this.throwIfDisposed();
        const groupIdBytes = dataUtils.dataToUint8Array(groupId, 'utf8');
        this.validateGroupId(groupIdBytes);
        const sessionId = computeSessionId(groupIdBytes);
        const initialEpoch = createInitialEpoch(sessionId);
        const initialEpochMessage = initialEpoch.serialize();
        initialEpoch.delete();
        return createVirgilGroupSession([initialEpochMessage]);
    }
    importGroupSession(epochMessages) {
        this.throwIfDisposed();
        if (!Array.isArray(epochMessages)) {
            throw new TypeError('Epoch messages must be an array.');
        }
        if (epochMessages.length === 0) {
            throw new Error('Epoch messages must not be empty.');
        }
        return createVirgilGroupSession(epochMessages.map(it => dataUtils.dataToUint8Array(it, 'base64')));
    }
    calculateGroupSessionId(groupId) {
        this.throwIfDisposed();
        const groupIdBytes = dataUtils.dataToUint8Array(groupId, 'utf8');
        this.validateGroupId(groupIdBytes);
        return dataUtils.toBuffer(computeSessionId(groupIdBytes)).toString('hex');
    }
    validateGroupId(groupId) {
        if (groupId.byteLength < MIN_GROUP_ID_BYTE_LENGTH) {
            throw new Error(`The given group Id is too short. Must be at least ${MIN_GROUP_ID_BYTE_LENGTH} bytes.`);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    createHash(data, HashClass) {
        const hashInstance = new HashClass();
        const hash = hashInstance.hash(data);
        hashInstance.delete();
        return hash;
    }
    calculateKeypairIdentifier(serializedPublicKey, useSha256Identifiers) {
        if (useSha256Identifiers) {
            return this.createHash(serializedPublicKey, getFoundationModules().Sha256);
        }
        return this.createHash(serializedPublicKey, getFoundationModules().Sha512).slice(0, 8);
    }
    throwIfDisposed() {
        if (this._isDisposed) {
            throw new Error('Cannot use an instance of `VirgilCrypto` class after the `dispose` method has been called.');
        }
    }
}

Object.keys(sdkCrypto).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return sdkCrypto[k];
    }
  });
});
exports.HashAlgorithm = HashAlgorithm;
exports.KeyPairType = KeyPairType;
exports.VirgilCrypto = VirgilCrypto;
exports.VirgilPrivateKey = VirgilPrivateKey;
exports.VirgilPublicKey = VirgilPublicKey;
exports.VirgilStreamCipher = VirgilStreamCipher;
exports.VirgilStreamDecipher = VirgilStreamDecipher;
exports.VirgilStreamSigner = VirgilStreamSigner;
exports.VirgilStreamVerifier = VirgilStreamVerifier;
exports.getFoundationModules = getFoundationModules;
exports.hasFoundationModules = hasFoundationModules;
exports.initCrypto = initCrypto;
exports.moduleInitializer = moduleInitializer;
exports.setFoundationModules = setFoundationModules;
