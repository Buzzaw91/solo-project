let socketioJwt,config;_fd3‍.x([["default",()=>_fd3‍.o]]);_fd3‍.w("socketio-jwt",[["default",["socketioJwt"],function(v){socketioJwt=v}]]);_fd3‍.w("./index",[["default",["config"],function(v){config=v}]]);


const _fd3‍anonymous=io => {
  // // JWT middleware for socket.io
  // io.use(socketioJwt.authorize({
  //   secret: config.JWT_SECRET,
  //   handshake: true,
  //   auth_header_required: true
  // }));

  // // fires when a user is connected
  // // this only happens when a user authenticates (after login)
  // io.on('connection', (socket) => {
  //   const userId = socket.decoded_token.id

  //   console.log('a user connected', socket.id)

  //   // create a room with userId
  //   // useful for sending data to a single online user
  //   socket.join(userId)

  //   // join all-users room. we use this to send the changes to all online users
  //   socket.join('all-users')

  //   // no need to leave room, because socket.io automatically does that
  //   socket.on('disconnect', () => {
  //     console.log('a user disconnected', userId)
  //   })
  // })
  io
	.on('connection', socketioJwt.authorize({
    secret: config.JWT_SECRET,
    handshake: true,
		timeout: 15000, // 15 seconds to send the authentication message
	}))
	.on('authenticated', function(socket){
		_fd3‍.g.console.log('connected & authenticated: ' + JSON.stringify(socket.decoded_token));
		socket.on('chat message', function(msg){
			debugger;
			io.emit('chat message', msg);
		});
	});






};_fd3‍.d(_fd3‍anonymous);
